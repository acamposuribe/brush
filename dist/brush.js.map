{"version":3,"file":"brush.js","sources":["../node_modules/simplex-noise/dist/esm/simplex-noise.js","../node_modules/esm-seedrandom/esm/index.mjs","../src/core/utils.js","../src/core/gl/blend.js","../src/core/workers.js","../src/core/color.js","../src/core/flowfield.js","../src/core/save.js","../src/core/mask.js","../src/core/erase.js","../src/core/polygon.js","../src/core/plot.js","../src/core/primitives.js","../src/core/loop.js","../src/stroke/gl_draw.js","../src/core/gl/utils.js","../src/stroke/stroke.js","../src/hatch/hatch.js","../src/fill/fill.js"],"sourcesContent":["/*\n * A fast javascript implementation of simplex noise by Jonas Wagner\n\nBased on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\nWhich is based on example code by Stefan Gustavson (stegu@itn.liu.se).\nWith Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\nBetter rank ordering method by Stefan Gustavson in 2012.\n\n Copyright (c) 2024 Jonas Wagner\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n// these __PURE__ comments help uglifyjs with dead code removal\n//\nconst SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);\nconst SQRT5 = /*#__PURE__*/ Math.sqrt(5.0);\nconst F2 = 0.5 * (SQRT3 - 1.0);\nconst G2 = (3.0 - SQRT3) / 6.0;\nconst F3 = 1.0 / 3.0;\nconst G3 = 1.0 / 6.0;\nconst F4 = (SQRT5 - 1.0) / 4.0;\nconst G4 = (5.0 - SQRT5) / 20.0;\n// I'm really not sure why this | 0 (basically a coercion to int)\n// is making this faster but I get ~5 million ops/sec more on the\n// benchmarks across the board or a ~10% speedup.\nconst fastFloor = (x) => Math.floor(x) | 0;\nconst grad2 = /*#__PURE__*/ new Float64Array([1, 1,\n    -1, 1,\n    1, -1,\n    -1, -1,\n    1, 0,\n    -1, 0,\n    1, 0,\n    -1, 0,\n    0, 1,\n    0, -1,\n    0, 1,\n    0, -1]);\n// double seems to be faster than single or int's\n// probably because most operations are in double precision\nconst grad3 = /*#__PURE__*/ new Float64Array([1, 1, 0,\n    -1, 1, 0,\n    1, -1, 0,\n    -1, -1, 0,\n    1, 0, 1,\n    -1, 0, 1,\n    1, 0, -1,\n    -1, 0, -1,\n    0, 1, 1,\n    0, -1, 1,\n    0, 1, -1,\n    0, -1, -1]);\n// double is a bit quicker here as well\nconst grad4 = /*#__PURE__*/ new Float64Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,\n    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,\n    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,\n    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,\n    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,\n    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,\n    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,\n    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);\n/**\n * Creates a 2D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction2D}\n */\nexport function createNoise2D(random = Math.random) {\n    const perm = buildPermutationTable(random);\n    // precalculating this yields a little ~3% performance improvement.\n    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);\n    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);\n    return function noise2D(x, y) {\n        // if(!isFinite(x) || !isFinite(y)) return 0;\n        let n0 = 0; // Noise contributions from the three corners\n        let n1 = 0;\n        let n2 = 0;\n        // Skew the input space to determine which simplex cell we're in\n        const s = (x + y) * F2; // Hairy factor for 2D\n        const i = fastFloor(x + s);\n        const j = fastFloor(y + s);\n        const t = (i + j) * G2;\n        const X0 = i - t; // Unskew the cell origin back to (x,y) space\n        const Y0 = j - t;\n        const x0 = x - X0; // The x,y distances from the cell origin\n        const y0 = y - Y0;\n        // For the 2D case, the simplex shape is an equilateral triangle.\n        // Determine which simplex we are in.\n        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n        if (x0 > y0) {\n            i1 = 1;\n            j1 = 0;\n        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        else {\n            i1 = 0;\n            j1 = 1;\n        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n        // c = (3-sqrt(3))/6\n        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n        const y1 = y0 - j1 + G2;\n        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n        const y2 = y0 - 1.0 + 2.0 * G2;\n        // Work out the hashed gradient indices of the three simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        // Calculate the contribution from the three corners\n        let t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 >= 0) {\n            const gi0 = ii + perm[jj];\n            const g0x = permGrad2x[gi0];\n            const g0y = permGrad2y[gi0];\n            t0 *= t0;\n            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient\n            n0 = t0 * t0 * (g0x * x0 + g0y * y0);\n        }\n        let t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 >= 0) {\n            const gi1 = ii + i1 + perm[jj + j1];\n            const g1x = permGrad2x[gi1];\n            const g1y = permGrad2y[gi1];\n            t1 *= t1;\n            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);\n            n1 = t1 * t1 * (g1x * x1 + g1y * y1);\n        }\n        let t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 >= 0) {\n            const gi2 = ii + 1 + perm[jj + 1];\n            const g2x = permGrad2x[gi2];\n            const g2y = permGrad2y[gi2];\n            t2 *= t2;\n            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);\n            n2 = t2 * t2 * (g2x * x2 + g2y * y2);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 70.0 * (n0 + n1 + n2);\n    };\n}\n/**\n * Creates a 3D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction3D}\n */\nexport function createNoise3D(random = Math.random) {\n    const perm = buildPermutationTable(random);\n    // precalculating these seems to yield a speedup of over 15%\n    const permGrad3x = new Float64Array(perm).map(v => grad3[(v % 12) * 3]);\n    const permGrad3y = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 1]);\n    const permGrad3z = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 2]);\n    return function noise3D(x, y, z) {\n        let n0, n1, n2, n3; // Noise contributions from the four corners\n        // Skew the input space to determine which simplex cell we're in\n        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D\n        const i = fastFloor(x + s);\n        const j = fastFloor(y + s);\n        const k = fastFloor(z + s);\n        const t = (i + j + k) * G3;\n        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n        const Y0 = j - t;\n        const Z0 = k - t;\n        const x0 = x - X0; // The x,y,z distances from the cell origin\n        const y0 = y - Y0;\n        const z0 = z - Z0;\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n        // Determine which simplex we are in.\n        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n        if (x0 >= y0) {\n            if (y0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            } // X Y Z order\n            else if (x0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            } // X Z Y order\n            else {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            } // Z X Y order\n        }\n        else { // x0<y0\n            if (y0 < z0) {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            } // Z Y X order\n            else if (x0 < z0) {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            } // Y Z X order\n            else {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            } // Y X Z order\n        }\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n        // c = 1/6.\n        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n        const y1 = y0 - j1 + G3;\n        const z1 = z0 - k1 + G3;\n        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n        const y2 = y0 - j2 + 2.0 * G3;\n        const z2 = z0 - k2 + 2.0 * G3;\n        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n        const y3 = y0 - 1.0 + 3.0 * G3;\n        const z3 = z0 - 1.0 + 3.0 * G3;\n        // Work out the hashed gradient indices of the four simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const kk = k & 255;\n        // Calculate the contribution from the four corners\n        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n        if (t0 < 0)\n            n0 = 0.0;\n        else {\n            const gi0 = ii + perm[jj + perm[kk]];\n            t0 *= t0;\n            n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);\n        }\n        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n        if (t1 < 0)\n            n1 = 0.0;\n        else {\n            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];\n            t1 *= t1;\n            n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);\n        }\n        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n        if (t2 < 0)\n            n2 = 0.0;\n        else {\n            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2]];\n            t2 *= t2;\n            n2 = t2 * t2 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);\n        }\n        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n        if (t3 < 0)\n            n3 = 0.0;\n        else {\n            const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];\n            t3 *= t3;\n            n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to stay just inside [-1,1]\n        return 32.0 * (n0 + n1 + n2 + n3);\n    };\n}\n/**\n * Creates a 4D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction4D}\n */\nexport function createNoise4D(random = Math.random) {\n    const perm = buildPermutationTable(random);\n    // precalculating these leads to a ~10% speedup\n    const permGrad4x = new Float64Array(perm).map(v => grad4[(v % 32) * 4]);\n    const permGrad4y = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 1]);\n    const permGrad4z = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 2]);\n    const permGrad4w = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 3]);\n    return function noise4D(x, y, z, w) {\n        let n0, n1, n2, n3, n4; // Noise contributions from the five corners\n        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n        const s = (x + y + z + w) * F4; // Factor for 4D skewing\n        const i = fastFloor(x + s);\n        const j = fastFloor(y + s);\n        const k = fastFloor(z + s);\n        const l = fastFloor(w + s);\n        const t = (i + j + k + l) * G4; // Factor for 4D unskewing\n        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n        const Y0 = j - t;\n        const Z0 = k - t;\n        const W0 = l - t;\n        const x0 = x - X0; // The x,y,z,w distances from the cell origin\n        const y0 = y - Y0;\n        const z0 = z - Z0;\n        const w0 = w - W0;\n        // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n        // To find out which of the 24 possible simplices we're in, we need to\n        // determine the magnitude ordering of x0, y0, z0 and w0.\n        // Six pair-wise comparisons are performed between each possible pair\n        // of the four coordinates, and the results are used to rank the numbers.\n        let rankx = 0;\n        let ranky = 0;\n        let rankz = 0;\n        let rankw = 0;\n        if (x0 > y0)\n            rankx++;\n        else\n            ranky++;\n        if (x0 > z0)\n            rankx++;\n        else\n            rankz++;\n        if (x0 > w0)\n            rankx++;\n        else\n            rankw++;\n        if (y0 > z0)\n            ranky++;\n        else\n            rankz++;\n        if (y0 > w0)\n            ranky++;\n        else\n            rankw++;\n        if (z0 > w0)\n            rankz++;\n        else\n            rankw++;\n        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n        // impossible. Only the 24 indices which have non-zero entries make any sense.\n        // We use a thresholding to set the coordinates in turn from the largest magnitude.\n        // Rank 3 denotes the largest coordinate.\n        // Rank 2 denotes the second largest coordinate.\n        // Rank 1 denotes the second smallest coordinate.\n        // The integer offsets for the second simplex corner\n        const i1 = rankx >= 3 ? 1 : 0;\n        const j1 = ranky >= 3 ? 1 : 0;\n        const k1 = rankz >= 3 ? 1 : 0;\n        const l1 = rankw >= 3 ? 1 : 0;\n        // The integer offsets for the third simplex corner\n        const i2 = rankx >= 2 ? 1 : 0;\n        const j2 = ranky >= 2 ? 1 : 0;\n        const k2 = rankz >= 2 ? 1 : 0;\n        const l2 = rankw >= 2 ? 1 : 0;\n        // The integer offsets for the fourth simplex corner\n        const i3 = rankx >= 1 ? 1 : 0;\n        const j3 = ranky >= 1 ? 1 : 0;\n        const k3 = rankz >= 1 ? 1 : 0;\n        const l3 = rankw >= 1 ? 1 : 0;\n        // The fifth corner has all coordinate offsets = 1, so no need to compute that.\n        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n        const y1 = y0 - j1 + G4;\n        const z1 = z0 - k1 + G4;\n        const w1 = w0 - l1 + G4;\n        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n        const y2 = y0 - j2 + 2.0 * G4;\n        const z2 = z0 - k2 + 2.0 * G4;\n        const w2 = w0 - l2 + 2.0 * G4;\n        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n        const y3 = y0 - j3 + 3.0 * G4;\n        const z3 = z0 - k3 + 3.0 * G4;\n        const w3 = w0 - l3 + 3.0 * G4;\n        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n        const y4 = y0 - 1.0 + 4.0 * G4;\n        const z4 = z0 - 1.0 + 4.0 * G4;\n        const w4 = w0 - 1.0 + 4.0 * G4;\n        // Work out the hashed gradient indices of the five simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const kk = k & 255;\n        const ll = l & 255;\n        // Calculate the contribution from the five corners\n        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n        if (t0 < 0)\n            n0 = 0.0;\n        else {\n            const gi0 = ii + perm[jj + perm[kk + perm[ll]]];\n            t0 *= t0;\n            n0 = t0 * t0 * (permGrad4x[gi0] * x0 + permGrad4y[gi0] * y0 + permGrad4z[gi0] * z0 + permGrad4w[gi0] * w0);\n        }\n        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n        if (t1 < 0)\n            n1 = 0.0;\n        else {\n            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]];\n            t1 *= t1;\n            n1 = t1 * t1 * (permGrad4x[gi1] * x1 + permGrad4y[gi1] * y1 + permGrad4z[gi1] * z1 + permGrad4w[gi1] * w1);\n        }\n        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n        if (t2 < 0)\n            n2 = 0.0;\n        else {\n            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]];\n            t2 *= t2;\n            n2 = t2 * t2 * (permGrad4x[gi2] * x2 + permGrad4y[gi2] * y2 + permGrad4z[gi2] * z2 + permGrad4w[gi2] * w2);\n        }\n        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n        if (t3 < 0)\n            n3 = 0.0;\n        else {\n            const gi3 = ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]];\n            t3 *= t3;\n            n3 = t3 * t3 * (permGrad4x[gi3] * x3 + permGrad4y[gi3] * y3 + permGrad4z[gi3] * z3 + permGrad4w[gi3] * w3);\n        }\n        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n        if (t4 < 0)\n            n4 = 0.0;\n        else {\n            const gi4 = ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]];\n            t4 *= t4;\n            n4 = t4 * t4 * (permGrad4x[gi4] * x4 + permGrad4y[gi4] * y4 + permGrad4z[gi4] * z4 + permGrad4w[gi4] * w4);\n        }\n        // Sum up and scale the result to cover the range [-1,1]\n        return 27.0 * (n0 + n1 + n2 + n3 + n4);\n    };\n}\n/**\n * Builds a random permutation table.\n * This is exported only for (internal) testing purposes.\n * Do not rely on this export.\n * @private\n */\nexport function buildPermutationTable(random) {\n    const tableSize = 512;\n    const p = new Uint8Array(tableSize);\n    for (let i = 0; i < tableSize / 2; i++) {\n        p[i] = i;\n    }\n    for (let i = 0; i < tableSize / 2 - 1; i++) {\n        const r = i + ~~(random() * (256 - i));\n        const aux = p[i];\n        p[i] = p[r];\n        p[r] = aux;\n    }\n    for (let i = 256; i < tableSize; i++) {\n        p[i] = p[i - 256];\n    }\n    return p;\n}\n//# sourceMappingURL=simplex-noise.js.map","function _prng_restore(prng, xg, opts) {\n  let state = opts && opts.state;\n  if (state) {\n    if (typeof(state) == 'object') xg.copy(state, xg);\n    prng.state = () => xg.copy(xg, {});\n  }\n}\n\nfunction _prng_xor_core(xg, opts) {\n  let prng = () => (xg.next() >>> 0) / 0x100000000;\n\n  prng.double = () => {\n    let top, bot, result;\n    do {\n      top = xg.next() >>> 11;\n      bot = (xg.next() >>> 0) / 0x100000000;\n      result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n\n  prng.int32 = () => xg.next() | 0;\n\n  prng.quick = prng;\n\n  _prng_restore(prng, xg, opts);\n  return prng;\n}\n\n// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\nfunction prng_alea(seed, opts) {\n  let xg = new AleaGen(seed);\n\n  let prng = () => xg.next();\n\n  prng.double = () =>\n    prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n\n  prng.int32 = () => (xg.next() * 0x100000000) | 0;\n\n  prng.quick = prng;\n\n  _prng_restore(prng, xg, opts);\n  return prng\n}\n\nclass AleaGen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let n = 0xefc8249d;\n\n    // Apply the seeding algorithm from Baagoe.\n    this.c = 1;\n    this.s0 = mash(' ');\n    this.s1 = mash(' ');\n    this.s2 = mash(' ');\n    this.s0 -= mash(seed);\n    if (this.s0 < 0) { this.s0 += 1; }\n    this.s1 -= mash(seed);\n    if (this.s1 < 0) { this.s1 += 1; }\n    this.s2 -= mash(seed);\n    if (this.s2 < 0) { this.s2 += 1; }\n\n    function mash(data) {\n      data = String(data);\n      for (let i = 0; i < data.length; i++) {\n        n += data.charCodeAt(i);\n        let h = 0.02519603282416938 * n;\n        n = h >>> 0;\n        h -= n;\n        h *= n;\n        n = h >>> 0;\n        h -= n;\n        n += h * 0x100000000; // 2^32\n      }\n      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n    }\n  }\n\n  next() {\n    let {c,s0,s1,s2} = this;\n    let t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n    this.s0 = s1;\n    this.s1 = s2;\n    return this.s2 = t - (this.c = t | 0);\n  }\n\n  copy(f, t) {\n    t.c = f.c;\n    t.s0 = f.s0;\n    t.s1 = f.s1;\n    t.s2 = f.s2;\n    return t;\n  }\n}\n\n// A Javascript implementaion of the \"xor128\" prng algorithm by\nfunction prng_xor128(seed, opts) {\n  let xg = new Xor128Gen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\nclass Xor128Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let strseed = '';\n\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 0;\n\n    if (seed === (seed | 0)) {\n      // Integer seed.\n      this.x = seed;\n    } else {\n      // String seed.\n      strseed += seed;\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let k = 0; k < strseed.length + 64; k++) {\n      this.x ^= strseed.charCodeAt(k) | 0;\n      this.next();\n    }\n  }\n\n  next() {\n    let {x,y,z,w} = this;\n    let t = x ^ (x << 11);\n    this.x = y;\n    this.y = z;\n    this.z = w;\n    return this.w = w ^ ((w >>> 19) ^ t ^ (t >>> 8));\n  };\n\n  copy(f, t) {\n    t.x = f.x;\n    t.y = f.y;\n    t.z = f.z;\n    t.w = f.w;\n    return t;\n  }\n}\n\n// A Javascript implementaion of the \"xorwow\" prng algorithm by\nfunction prng_xorwow(seed, opts) {\n  let xg = new XorWowGen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\nclass XorWowGen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let strseed = '';\n\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 0;\n    this.v = 0;\n\n    if (seed === (seed | 0)) {\n      // Integer seed.\n      this.x = seed;\n    } else {\n      // String seed.\n      strseed += seed;\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let k = 0; k < strseed.length + 64; k++) {\n      this.x ^= strseed.charCodeAt(k) | 0;\n      if (k == strseed.length) {\n        this.d = this.x << 10 ^ this.x >>> 4;\n      }\n      this.next();\n    }\n  }\n\n  next() {\n    let {x,y,z,w,v,d} = this;\n    let t = (x ^ (x >>> 2));\n    this.x = y;\n    this.y = z;\n    this.z = w;\n    this.w = v;\n    return (this.d = (d + 362437 | 0)) +\n       (this.v = (v ^ (v << 4)) ^ (t ^ (t << 1))) | 0;\n  };\n\n  copy(f, t) {\n    t.x = f.x;\n    t.y = f.y;\n    t.z = f.z;\n    t.w = f.w;\n    t.v = f.v;\n    t.d = f.d;\n    return t;\n  }\n}\n\n// A Javascript implementaion of the \"xorshift7\" algorithm by\nfunction prng_xorshift7(seed, opts) {\n  let xg = new XorShift7Gen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\n\nclass XorShift7Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    var j, w, x = [];\n\n    if (seed === (seed | 0)) {\n      // Seed state array using a 32-bit integer.\n      w = x[0] = seed;\n    } else {\n      // Seed state using a string.\n      seed = '' + seed;\n      for (j = 0; j < seed.length; ++j) {\n        x[j & 7] = (x[j & 7] << 15) ^\n            (seed.charCodeAt(j) + x[(j + 1) & 7] << 13);\n      }\n    }\n\n    // Enforce an array length of 8, not all zeroes.\n    while (x.length < 8) x.push(0);\n    for (j = 0; j < 8 && x[j] === 0; ++j);\n    if (j == 8) w = x[7] = -1; else w = x[j];\n\n    this.x = x;\n    this.i = 0;\n\n    // Discard an initial 256 values.\n    for (j = 256; j > 0; --j) {\n      this.next();\n    }\n  }\n\n  next() {\n    // Update xor generator.\n    let t, v, {x,i} = this;\n    t = x[i]; t ^= (t >>> 7); v = t ^ (t << 24);\n    t = x[(i + 1) & 7]; v ^= t ^ (t >>> 10);\n    t = x[(i + 3) & 7]; v ^= t ^ (t >>> 3);\n    t = x[(i + 4) & 7]; v ^= t ^ (t << 7);\n    t = x[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);\n    x[i] = v;\n    this.i = (i + 1) & 7;\n    return v;\n  };\n\n  copy(f, t) {\n    t.x = [... f.x];\n    t.i = f.i;\n    return t;\n  }\n}\n\n// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\nfunction prng_xor4096(seed, opts) {\n  let xg = new Xor4096Gen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\n\nclass Xor4096Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    this.w = w;\n    this.X = X;\n    this.i = i;\n  }\n\n  next() {\n    let t, v, {w, X, i} = this;\n    // Update Weyl generator.\n    this.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    this.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  }\n\n  copy(f, t) {\n    t.i = f.i;\n    t.w = f.w;\n    t.X = [... f.X];\n    return t;\n  }\n}\n\n// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\nfunction prng_tychei(seed, opts) {\n  let xg = new TycheiGen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\nclass TycheiGen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let strseed = '';\n\n    this.a = 0;\n    this.b = 0;\n    this.c = 2654435769 | 0;\n    this.d = 1367130551;\n\n    if (seed === Math.floor(seed)) {\n      // Integer seed.\n      this.a = (seed / 0x100000000) | 0;\n      this.b = seed | 0;\n    } else {\n      // String seed.\n      strseed += seed;\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let k = 0; k < strseed.length + 20; k++) {\n      this.b ^= strseed.charCodeAt(k) | 0;\n      this.next();\n    }\n  }\n\n  next() {\n    let {a,b,c,d} = this;\n    b = (b << 25) ^ (b >>> 7) ^ c;\n    c = (c - d) | 0;\n    d = (d << 24) ^ (d >>> 8) ^ a;\n    a = (a - b) | 0;\n    this.b = b = (b << 20) ^ (b >>> 12) ^ c;\n    this.c = c = (c - d) | 0;\n    this.d = (d << 16) ^ (c >>> 16) ^ a;\n    return this.a = (a - b) | 0;\n  };\n\n  copy(f, t) {\n    t.a = f.a;\n    t.b = f.b;\n    t.c = f.c;\n    t.d = f.d;\n    return t;\n  }\n}\n\n\n/* The following is non-inverted tyche, which has better internal\n * bit diffusion, but which is about 25% slower than tyche-i in JS.\n *\n\nclass TycheiGenAlt extends TycheiGen {\n  next() {\n    let {a,b,c,d} = this\n    a = (a + b | 0) >>> 0;\n    d = d ^ a; d = d << 16 ^ d >>> 16;\n    c = c + d | 0;\n    b = b ^ c; b = b << 12 ^ d >>> 20;\n    this.a = a = a + b | 0;\n    d = d ^ a; this.d = d = d << 8 ^ d >>> 24;\n    this.c = c = c + d | 0;\n    b = b ^ c;\n    return this.b = (b << 7 ^ b >>> 25);\n  }\n}\n*/\n\n/*\nCopyright 2019 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\nfunction prng_arc4(seed, opts) {\n  let xg = new ARC4Gen(seed);\n  let prng = () => xg.next();\n\n  prng.double = prng;\n\n  prng.int32 = () => xg.g(4) | 0;\n\n  prng.quick = () => xg.g(4) / 0x100000000;\n\n  _prng_restore(prng, xg, opts);\n  return prng\n}\n\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\n\n//\n// The following constants are related to IEEE 754 limits.\n//\n\n// const width = 256 // each RC4 output is 0 <= x < 256\n// const chunks = 6 // at least six RC4 outputs for each double\nconst _arc4_startdenom = 281474976710656;     // 256 ** 6 == width ** chunks\nconst _arc4_significance = 4503599627370496;  // 2 ** 52 significant digits in a double\nconst _arc4_overflow = 9007199254740992;      // 2 ** 53 == significance * 2\n\n\nclass ARC4Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let key = this.mixkey(seed, []);\n    let i,j,t, S=[], keylen = key.length;\n    this.i = this.j = i = j = 0;\n    this.S = S;\n\n    // The empty key [] is treated as [0].\n    if (!keylen) { key = [keylen++]; }\n\n    // Set up S using the standard key scheduling algorithm.\n    while (i <= 0xff) {\n      S[i] = i++;\n    }\n    for (i = 0; i <= 0xff; i++) {\n      S[i] = S[j = 0xff & (j + key[i % keylen] + (t = S[i]))];\n      S[j] = t;\n    }\n\n    // For robust unpredictability, the function call below automatically\n    // discards an initial batch of values.  This is called RC4-drop[256].\n    // See http://google.com/search?q=rsa+fluhrer+response&btnI\n    this.g(256);\n  }\n\n  next() {\n    // This function returns a random double in [0, 1) that contains\n    // randomness in every bit of the mantissa of the IEEE 754 value.\n\n    let n = this.g(6);                  // Start with a numerator n < 2 ^ 48\n    let d = _arc4_startdenom;           //   and denominator d = 2 ^ 48.\n    let x = 0;                          //   and no 'extra last byte'.\n\n    while (n < _arc4_significance) {    // Fill up all significant digits (2 ** 52)\n      n = (n + x) * 256;                //   by shifting numerator and\n      d *= 256;                         //   denominator and generating a\n      x = this.g(1);                    //   new least-significant-byte.\n    }\n    while (n >= _arc4_overflow) {       // To avoid rounding past overflow, before adding\n      n /= 2;                           //   last byte, shift everything\n      d /= 2;                           //   right using integer math until\n      x >>>= 1;                         //   we have exactly the desired bits.\n    }\n    return (n + x) / d;                 // Form the number within [0, 1).\n  }\n\n  g(count) {\n    // The \"g\" method returns the next (count) outputs as one number.\n    let t, r = 0, {i,j,S} = this;\n    while (count--) {\n      t = S[i = 0xff & (i + 1)];\n      r = r * 256 + S[0xff & ((S[i] = S[j = 0xff & (j + t)]) + (S[j] = t))];\n    }\n    this.i = i;\n    this.j = j;\n    return r;\n  }\n\n  copy(f, t) {\n    t.i = f.i;\n    t.j = f.j;\n    t.S = [... f.S];\n    return t;\n  }\n\n  mixkey(seed, key) {\n    seed = seed + '';\n    let smear=0, j=0;\n    while (j < seed.length) {\n      key[0xff & j] =\n        0xff & ((smear ^= key[0xff & j] * 19) + seed.charCodeAt(j++));\n    }\n    return key\n  }\n}\n\nexport { prng_alea, prng_arc4, prng_tychei, prng_xor128, prng_xor4096, prng_xorshift7, prng_xorwow };\n//# sourceMappingURL=index.mjs.map\n","// =============================================================================\n// Section: Randomness & Noise\n// =============================================================================\n\nimport { createNoise2D } from \"simplex-noise\";\nimport { prng_alea } from \"esm-seedrandom\";\n\n/**\n * A uniform PRNG function. Returns a float in [0,1).\n * @callback RNG\n * @returns {number}\n */\n/** @type {RNG} */\nlet rng = prng_alea(Math.random());\n\n/**\n * Seed the random number generator.\n * @param {number|string} s – The seed value.\n * @returns {void}\n */\nexport function seed(s) {\n  rng = prng_alea(s);\n}\n\n/**\n * Simplex‐noise 2D function.\n * @type {function(number, number): number}\n */\nexport let noise = createNoise2D(prng_alea(Math.random()));\n\n/**\n * Seed the noise generator.\n * @param {number|string} s - The seed value.\n * @returns {void}\n */\nexport function noiseSeed(s) {\n  noise = createNoise2D(prng_alea(s));\n}\n\n/**\n * Returns a random float in [min, max).\n * @param {number} [min=0]\n * @param {number} [max=1]\n * @returns {number}\n */\nexport const rr = (e = 0, r = 1) => e + rng() * (r - e);\n\n/**\n * Selects a random element from an array.\n * @param {T[]} array - Input array.\n * @returns {T}\n */\nexport function rArray(array) {\n  return array[~~(rng() * array.length)]\n}\n\n/**\n * Generates a random number or picks a random array element.\n * @param {number|Array} [minOrArr=0]\n * @param {number} [max=1]\n * @returns {number}\n */\nexport function random(e = 0, r = 1) {\n  if (Array.isArray(e)) return rArray(e);\n  if (arguments.length === 1) return rng() * e;\n  return rr(...arguments);\n}\n\n/**\n * Returns a random integer in [min, max).\n * @param {number} min\n * @param {number} max\n * @returns {number}\n */\nexport const randInt = (e, r) => ~~rr(e, r);\n\n/**\n * Gaussian (normal) random sample N(mean, stdev²).\n * @param {number} [mean=0]\n * @param {number} [stdev=1]\n * @returns {number}\n */\nexport function gaussian(mean = 0, stdev = 1) {\n  const u = 1 - rng();\n  const v = rng();\n  const z = Math.sqrt(-2.0 * Math.log(u)) * cos(360 * v);\n  return z * stdev + mean;\n}\n\n/**\n * Picks a key from an object according to weighted probabilities.\n * @param {Object<string|number, number>} weights\n * @returns {string|number}\n */\nexport function weightedRand(weights) {\n  let totalWeight = 0;\n  const entries = [];\n\n  // Build cumulative weights array\n  for (const key in weights) {\n    totalWeight += weights[key];\n    entries.push({ key, cumulative: totalWeight });\n  }\n\n  // Get a random number between 0 and totalWeight\n  const rnd = rng() * totalWeight;\n\n  // Pick the first entry where rnd is less than the cumulative weight\n  for (const entry of entries) {\n    if (rnd < entry.cumulative) {\n      return isNaN(entry.key) ? entry.key : parseInt(entry.key);\n    }\n  }\n}\n\n// =============================================================================\n// Section: Numeric Mapping & Constraints\n// =============================================================================\n\n/**\n * Maps a value from range [a,b] to [c,d], optionally clamped.\n * @param {number} value\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} d\n * @param {boolean} [withinBounds=false]\n * @returns {number}\n */\nexport function map(value, a, b, c, d, withinBounds = false) {\n  let r = c + ((value - a) / (b - a)) * (d - c);\n  if (!withinBounds) return r;\n  if (c < d) {\n    return constrain(r, c, d);\n  } else {\n    return constrain(r, d, c);\n  }\n}\n\n/**\n * Constrains a number within the provided bounds.\n * @param {number} n - The number.\n * @param {number} low - Lower bound.\n * @param {number} high - Upper bound.\n * @returns {number} The constrained number.\n */\nexport function constrain(n, low, high) {\n  return Math.max(Math.min(n, high), low);\n}\n\n// =============================================================================\n// Section: Trigonometry\n// =============================================================================\n\n/**\n * Normalize an angle in degrees to [0,360).\n * @param {number} angle\n * @returns {number}\n */\nfunction nAngle(angle) {\n  angle = angle % 360;\n  return angle < 0 ? angle + 360 : angle;\n}\n\n// number of discrete steps (360° × 4 samples per degree)\nconst totalDegrees     = 1440;\nconst radiansPerIndex = (2 * Math.PI) / totalDegrees;\n\n// lazy‐initialized lookup tables\nconst c = new Float32Array(totalDegrees).fill(NaN);\nconst s = new Float32Array(totalDegrees).fill(NaN);\n\n/**\n * Cosine of an angle (degrees), via a lazy lookup table.\n * @param {number} angle\n * @returns {number}\n */\nexport function cos(angle) {\n  const idx = ~~(4 * nAngle(angle));\n  let v = c[idx];\n  if (isNaN(v)) {\n    v = Math.cos(idx * radiansPerIndex);\n    c[idx] = v;\n  }\n  return v;\n}\n\n/**\n * Sine of an angle (degrees), via a lazy lookup table.\n * @param {number} angle\n * @returns {number}\n */\nexport function sin(angle) {\n  const idx = ~~(4 * nAngle(angle));\n  let v = s[idx];\n  if (isNaN(v)) {\n    v = Math.sin(idx * radiansPerIndex);\n    s[idx] = v;\n  }\n  return v;\n}\n\n/**\n * Converts radians to degrees, normalized to [0,360).\n * @param {number} rad\n * @returns {number}\n */\nexport const toDegrees = (rad) => {\n  let angle = ((rad * 180) / Math.PI) % 360;\n  return angle < 0 ? angle + 360 : angle;\n};\n\n// =============================================================================\n// Section: Geometry & Transforms\n// =============================================================================\n\n/**\n * Rotates point (x,y) around center (cx,cy) by angle degrees.\n * @param {number} cx\n * @param {number} cy\n * @param {number} x\n * @param {number} y\n * @param {number} angle - Degrees\n * @returns {{x:number,y:number}}\n */\nexport function rotate(cx, cy, x, y, angle) {\n  let coseno = cos(angle),\n    seno = sin(angle),\n    nx = coseno * (x - cx) + seno * (y - cy) + cx,\n    ny = coseno * (y - cy) - seno * (x - cx) + cy;\n  return { x: nx, y: ny };\n}\n\n/**\n * Euclidean distance between two points.\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {number}\n */\nexport const dist = (x1, y1, x2, y2) =>\n  Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\n/**\n * Angle in degrees between two points, measured clockwise from +X.\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {number}\n */\nexport const calcAngle = (x1, y1, x2, y2) =>\n  toDegrees(Math.atan2(-(y2 - y1), x2 - x1));\n\n/**\n * Intersection of two line segments, or false if none.\n * @param {{x:number,y:number}} s1a\n * @param {{x:number,y:number}} s1b\n * @param {{x:number,y:number}} s2a\n * @param {{x:number,y:number}} s2b\n * @param {boolean} [includeSegmentExtension=false]\n * @returns {{x:number,y:number}|false}\n */\nexport function intersectLines(\n  s1a,\n  s1b,\n  s2a,\n  s2b,\n  includeSegmentExtension = false\n) {\n  // Extract coordinates from points\n  let x1 = s1a.x,\n    y1 = s1a.y;\n  let x2 = s1b.x,\n    y2 = s1b.y;\n  let x3 = s2a.x,\n    y3 = s2a.y;\n  let x4 = s2b.x,\n    y4 = s2b.y;\n  // Early return if line segments are points or if the lines are parallel\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false; // Segments are points\n  }\n  let deltaX1 = x2 - x1,\n    deltaY1 = y2 - y1;\n  let deltaX2 = x4 - x3,\n    deltaY2 = y4 - y3;\n  let denominator = deltaY2 * deltaX1 - deltaX2 * deltaY1;\n  if (denominator === 0) {\n    return false; // Lines are parallel\n  }\n  // Calculate the intersection point\n  let ua = (deltaX2 * (y1 - y3) - deltaY2 * (x1 - x3)) / denominator;\n  let ub = (deltaX1 * (y1 - y3) - deltaY1 * (x1 - x3)) / denominator;\n  // Check if the intersection is within the bounds of the line segments\n  if (!includeSegmentExtension && (ub < 0 || ub > 1)) {\n    return false;\n  }\n  // Calculate the intersection coordinates\n  let x = x1 + ua * deltaX1;\n  let y = y1 + ua * deltaY1;\n  return { x: x, y: y };\n}\n\n// =============================================================================\n// Section: Other Utility Functions\n// =============================================================================\n\n/**\n * Shallow‐clones an array of arrays.\n * @param {T[]} array\n * @returns {T[]}\n */\nexport function cloneArray(array) {\n  return array.map(function (arr) {\n    return arr.slice();\n  });\n}","import vertSrc from \"./shader.vert\";\nimport fragSrc from \"./shader.frag\";\n\n/**\n * This code will be compiled into a separate worker thread\n */\nexport const GL = () => {\n    let canvas, gl;\n    const sh = {}; // Stores shader uniform locations and FBOs/textures.\n\n    const createProgram = (gl, vert, frag) => {\n      const p = gl.createProgram();\n      for (let [t, src] of [\n          [gl.VERTEX_SHADER, vert],\n          [gl.FRAGMENT_SHADER, frag],\n      ]) {\n          const s = gl.createShader(t);\n          gl.shaderSource(s, src);\n          gl.compileShader(s);\n          gl.attachShader(p, s);\n      }\n      gl.linkProgram(p);\n      return p;\n  };\n\n    /**\n     * Creates a texture and allocates storage based on the canvas dimensions.\n     * @returns {WebGLTexture} The created texture.\n     */\n    function createTexture() {\n      const tex = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, tex);\n      gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, canvas.width, canvas.height);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      return tex;\n    }\n\n            /**\n     * Creates a framebuffer object (FBO) with an associated texture.\n     * @returns {{texture: WebGLTexture, fbo: WebGLFramebuffer}} An object containing the texture and FBO.\n     */\n    function createFBO() {\n      let texture = createTexture();\n      const fb = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        texture,\n        0\n      );\n      return { texture, fbo: fb };\n    }\n\n    /**\n     * Prepares the WebGL context:\n     * - Initializes WebGL2 with antialiasing disabled.\n     * - Compiles the shader program.\n     * - Caches uniform locations.\n     * - Creates necessary textures and framebuffer objects (FBOs).\n     * - Binds textures to texture units.\n     */\n    function prepareGL() {\n      gl = canvas.getContext(\"webgl2\", { antialias: false });\n\n      // Compile shader\n      const mainProg = createProgram(gl, vertSrc, fragSrc);\n      gl.useProgram(mainProg);\n\n      // Cache uniform locations used by the fragment shader.\n      [\n        \"u_addColor\",\n        \"u_isErase\",\n        \"u_isImage\",\n        \"u_isBrush\",\n        \"u_source\",\n        \"u_mask\"\n      ].forEach((name) => {\n        sh[name] = gl.getUniformLocation(mainProg, name);\n      });\n\n      // Create texture and framebuffer objects.\n      sh.mask = createTexture();\n      sh.source = createFBO();\n      sh.target = createFBO();\n\n      // Bind textures to texture units 0 and 1.\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, sh.source.texture);\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, sh.mask);\n      gl.uniform1i(sh.u_source, 0);\n      gl.uniform1i(sh.u_mask, 1);\n    }\n\n    /**\n     * Returns true if the worker is running in Safari.\n     * @returns {boolean} True if Safari, false otherwise.\n     */\n    function isSafari() {\n      return (\n        self.navigator &&\n        /Safari/.test(self.navigator.userAgent) &&\n        !/Chrome/.test(self.navigator.userAgent)\n      );\n    }\n\n    /**\n     * Applies the shader by updating the mask texture and drawing to framebuffer objects.\n     * Handles updating of uniforms and copying the rendered image between framebuffers.\n     * @param {object} data - Contains blend parameters and the mask ImageBitmap.\n     */\n    function applyShader(data) {\n      let imageData;\n      // Workaround for Safari memory leak using an OffscreenCanvas.\n      if (isSafari()) {\n        const offscreen = new OffscreenCanvas(\n          data.mask.width,\n          data.mask.height\n        );\n        const offctx = offscreen.getContext(\"2d\");\n        offctx.drawImage(data.mask, 0, 0);\n        imageData = offctx.getImageData(\n          0,\n          0,\n          data.mask.width,\n          data.mask.height\n        );\n      }\n      // Draw mask to texture\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        isSafari() ? imageData : data.mask\n      );\n      // Close imagebitmap\n      data.mask.close();\n      // Draw to framebuffer\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, sh.target.fbo);\n      // Uniforms\n      gl.uniform1i(sh.u_isImage, data.isImage ? 1 : 0);\n      gl.uniform1i(sh.u_isBrush, data.isBrush ? 1 : 0);\n      if (!data.isImage) {\n        gl.uniform1i(sh.u_isImage, false);\n        gl.uniform4f(sh.u_addColor, ...data.addColor);\n        gl.uniform1i(sh.u_isErase, data.isErase ? true : false);\n      }\n      // Composite image to frameBuffer\n      gl.drawArrays(gl.TRIANGLES, 0, 3);\n      // Copy framebuffer to source\n      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, sh.target.fbo);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, sh.source.fbo);\n      blit();\n      // Display framebuffer on canvas\n      if (data.isLast && !data.sp) {\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, sh.target.fbo); // Read from target\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null); // Draw to canvas\n        blit();\n      }\n    }\n\n    /**\n     * Copies the content from the current framebuffer to the destination using gl.blitFramebuffer.\n     */\n    function blit() {\n      gl.blitFramebuffer(\n        0,\n        0,\n        canvas.width,\n        canvas.height,\n        0,\n        0,\n        canvas.width,\n        canvas.height,\n        gl.COLOR_BUFFER_BIT,\n        gl.NEAREST\n      );\n    }\n\n    /**\n     * Message handler for the worker.\n     * - If a canvas is provided, initializes and prepares the WebGL context.\n     * - If a background-clear message is received, clears the background.\n     * - If mask data is received, applies the shader.\n     */\n    onmessage = async (event) => {\n      if (event.data.canvas) {\n        canvas = event.data.canvas;\n        prepareGL();\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, sh.source.fbo);\n        gl.clearColor(1, 1, 1, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      } else if (event.data.isBG) {\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, sh.source.fbo);\n        gl.clearColor(...event.data.color);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      } else if (event.data.mask) {\n        applyShader(event.data);\n      }\n    };\n  }","import { GL } from \"./gl/blend.js\";\n\n// Create a blob URL from a function or string for worker creation.\nWorker.createURL = function (func_or_string) {\n  const str =\n    typeof func_or_string === \"function\"\n      ? func_or_string.toString()\n      : func_or_string;\n  const blob = new Blob([\"'use strict';\\nself.onmessage=\" + str], {\n    type: \"text/javascript\",\n  });\n  return window.URL.createObjectURL(blob);\n};\n\n// Create a new Worker instance from a function or string.\nWorker.create = function (func_or_string) {\n  return new Worker(Worker.createURL(func_or_string));\n};\n\n/**\n * gl_worker:\n * A dedicated Web Worker for WebGL shader processing. It listens for messages to initialize\n * the WebGL context, clear backgrounds, apply shaders, and return processed images.\n * @returns {Worker} A new Web Worker instance.\n */\nexport const gl_worker = () =>\n  Worker.create(GL);\n","import { gl_worker } from \"./workers.js\";\nimport { constrain } from \"./utils.js\";\n\n// =============================================================================\n// Section: Configure and Initiate\n// =============================================================================\n/**\n * This module handles the configuration and initialization of the drawing system.\n * It manages canvas properties, ensures the system is ready for rendering, and\n * provides utilities for saving and restoring states.\n */\n\nconst Canvases = {}; // Stores canvas instances by ID\nexport let cID, Cwidth, Cheight, Density; // Global canvas properties\n\n/**\n * Loads and initializes a canvas for the drawing system.\n * @param {string} canvasID - Unique identifier for the canvas.\n * @param {HTMLCanvasElement} canvas - The canvas element to initialize.\n */\nexport function load(canvasID, canvas) {\n  cID = canvasID;\n  // Initialize the canvas if it hasn't been registered yet\n  if (!Canvases[cID]) {\n    Canvases[cID] = { canvas };\n  }\n  // Set canvas dimensions\n  Cwidth = Canvases[cID].canvas.width;\n  Cheight = Canvases[cID].canvas.height;\n  _isReady = true;\n  Mix.load();\n}\n\nlet _isReady = false;\n\n/**\n * Ensures the drawing system is ready before any operation.\n * Automatically loads the system if it hasn't been initialized.\n */\nfunction isCanvasReady() {\n  if (!_isReady) {\n    throw new Error(\"Canvas system is not ready. Call `load()` first.\");\n  }\n}\n\n/**\n * Stores the current state of the drawing system.\n * Can be used to save and restore configurations or canvas states.\n */\nexport const State = {};\n\n// =============================================================================\n// Section: Color Manager\n// =============================================================================\n/**\n * The Color Manager is responsible for handling color-related operations,\n * including color creation, conversion, and standardization. It provides\n * utilities to work with colors in various formats (e.g., RGB, Hexadecimal,\n * and named colors) and ensures compatibility with WebGL rendering.\n *\n * The `Color` class is the core of this section, offering methods to:\n * - Convert between RGB and Hexadecimal formats.\n * - Standardize color strings to their canonical form.\n * - Store color data in WebGL-compatible formats (normalized RGBA).\n */\n\nconst colorCanvas = document.createElement(\"canvas\");\ncolorCanvas.width = 1;\ncolorCanvas.height = 1;\nconst colorCtx = colorCanvas.getContext(\"2d\");\n\n/**\n * Class to deal with colours and their conversion\n */\nexport class Color {\n  constructor(r, g, b) {\n    if (isNaN(r)) {\n      // If the input is not a number, assume it's a color string (e.g., hex or named color)\n      this.hex = this.standardize(r);\n      let rgb = this.hexToRgb(this.hex);\n      this.r = rgb.r;\n      this.g = rgb.g;\n      this.b = rgb.b;\n    } else {\n      // Constrain RGB values to the range [0, 255]\n      r = constrain(r, 0, 255);\n      g = constrain(g, 0, 255);\n      b = constrain(b, 0, 255);\n      this.r = r;\n      this.g = isNaN(g) ? r : g;\n      this.b = isNaN(b) ? r : b;\n      this.hex = this.rgbToHex(this.r, this.g, this.b);\n    }\n    // Store the color in WebGL format (normalized RGBA)\n    this.gl = [this.r / 255, this.g / 255, this.b / 255, 1];\n  }\n\n  /**\n   * Converts RGB values to a hexadecimal color string.\n   * @param {number} r - Red value (0-255).\n   * @param {number} g - Green value (0-255).\n   * @param {number} b - Blue value (0-255).\n   * @returns {string} Hexadecimal color string.\n   */\n  rgbToHex(r, g, b) {\n    return \"#\" + ((1 << 24) | (r << 16) | (g << 8) | b).toString(16).slice(1);\n  }\n\n  /**\n   * Converts a hexadecimal color string to RGB values.\n   * @param {string} hex - Hexadecimal color string.\n   * @returns {object} An object with r, g, and b properties.\n   */\n  hexToRgb(hex) {\n    let shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n      return r + r + g + g + b + b;\n    });\n    let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n      ? {\n          r: parseInt(result[1], 16),\n          g: parseInt(result[2], 16),\n          b: parseInt(result[3], 16),\n        }\n      : null;\n  }\n\n  /**\n   * Standardizes a color string to its canonical form.\n   * @param {string} str - Color string (e.g., \"red\", \"#f00\").\n   * @returns {string} Standardized color string.\n   */\n  standardize(str) {\n    colorCtx.fillStyle = str;\n    return colorCtx.fillStyle;\n  }\n}\n\n// =============================================================================\n// Section: Color Blending\n// =============================================================================\n/**\n * Handles color blending using WebGL shaders. Implements advanced blending\n * effects based on Kubelka-Munk theory. Relies on spectral.js for blending logic.\n */\n\n/**\n * Ensures the Mix object is initialized and ready for blending.\n */\nexport function isMixReady() {\n  if (!Mix.loaded) {\n    isCanvasReady();\n    Mix.load();\n  }\n}\n\n/**\n * Manages blending operations with WebGL shaders.\n * @property {boolean} loaded - Indicates if shaders are loaded.\n * @property {boolean} isBlending - Indicates if blending is active.\n * @property {object} currentColor - Current color in WebGL format.\n * @property {function} load - Initializes blending resources.\n * @property {function} blend - Applies blending effects.\n */\nexport const Mix = {\n  loaded: false,\n  isBlending: false,\n  currentColor: new Color(\"white\").gl,\n\n  /**\n   * Loads necessary resources and prepares the mask buffer and shader for colour blending.\n   */\n  load() {\n    if (!Canvases[cID].worker) {\n      const ca = Canvases[cID];\n\n      // Create offscreen masks\n      ca.mask = new OffscreenCanvas(Cwidth, Cheight);\n      ca.glMask = new OffscreenCanvas(Cwidth, Cheight);\n      ca.ctx = ca.mask.getContext(\"2d\");\n      ca.gl = ca.glMask.getContext(\"webgl2\");\n      ca.ctx.lineWidth = 0;\n      \n      // Create an offscreen WebGL canvas and link it to the main canvas\n      ca.offscreen = Canvases[cID].canvas.transferControlToOffscreen();\n\n      // Initialize the WebGL worker\n      ca.worker = gl_worker();\n      ca.worker.postMessage(\"init\");\n\n      // Send the offscreen WebGL canvas to the worker\n      ca.worker.postMessage({ canvas: ca.offscreen }, [ca.offscreen]);\n    }\n\n    // Store references to the mask, context, and worker\n    Object.assign(this, Canvases[cID]);\n  },\n\n  /**\n   * Applies blending effects using the current color and mask.\n   * @param {Color} _color - Color to blend.\n   * @param {boolean} _isLast - If this is the final blend operation.\n   * @param {boolean} _isImg - If blending an image.\n   * @param {boolean} _isFillLayer - If this is a special case.\n   */\n  blend(_color = false, _isLast = false, _isImg = false, _isFillLayer = false) {\n    isMixReady();\n\n    // Initialize blending if not already active\n    if (!this.isBlending && _color) {\n      this.currentColor = _color.gl;\n      this.isBlending = true;\n    }\n\n    // Determine the new color\n    const newColor = !_color ? this.currentColor : _color.gl;\n\n    // Check if blending is necessary\n    const shouldBlend =\n      _isLast || _isImg || newColor.toString() !== this.currentColor.toString();\n\n    if (shouldBlend) {\n      // Use existing image data or transfer mask to ImageBitmap\n      const imageData =\n        _isImg || this.isBrush\n          ? this.glMask.transferToImageBitmap()\n          : this.mask.transferToImageBitmap();\n\n      // Send blending data to the worker\n      this.worker.postMessage(\n        {\n          addColor: this.currentColor,\n          mask: imageData,\n          isLast: _isLast,\n          isErase: this.isErase,\n          isImage: Boolean(_isImg),\n          sp: _isFillLayer,\n          isBrush: this.isBrush,\n        },\n        [imageData]\n      );\n\n      // Reset flags\n      this.isErase = false;\n      this.isBrush = false;\n\n      // Cache the new color if not the last operation\n      if (!_isLast) this.currentColor = _color.gl;\n\n      // Reset blending state if this is the last operation and is not a fill layer\n      if (_isLast && !_isFillLayer) this.isBlending = false;\n    }\n  },\n};\n\n// =============================================================================\n// Section: Functions Exposed to Users\n// =============================================================================\n\n/**\n * Stores the background color. Defaults to white.\n */\nlet _bg_Color = new Color(\"white\");\n\n/**\n * Sets the background color of the canvas.\n * @param {number|string} r - Red value (0-255) or a color string.\n * @param {number|string} g - Green value (0-255) or a color string.\n * @param {number} b - Blue value (0-255).\n */\nexport function background(r, g, b) {\n  isMixReady();\n\n  // Create a new Color object with the provided arguments\n  _bg_Color = new Color(...arguments);\n\n  // Send the background color to the worker\n  Mix.worker.postMessage({\n    color: _bg_Color.gl,\n    isBG: true,\n  });\n}\n\n/**\n * Draws an image onto the canvas.\n * @param {ImageBitmap|HTMLImageElement} img - The image to draw.\n * @param {number} [x=0] - X-coordinate of the image.\n * @param {number} [y=0] - Y-coordinate of the image.\n * @param {number} [w=img.width] - Width of the image.\n * @param {number} [h=img.height] - Height of the image.\n */\nexport function drawImage(img, x = 0, y = 0, w = img.width, h = img.height) {\n  isMixReady();\n\n  // Check if the image is not an ImageBitmap or if coordinates are non-default\n  if (\n    Object.prototype.toString.call(img) !== \"[object ImageBitmap]\" ||\n    x !== 0\n  ) {\n    // Draw the image onto the mask context\n    Mix.ctx.drawImage(img, x, y, w, h);\n\n    // Convert the mask to an ImageBitmap\n    img = Mix.mask.transferToImageBitmap();\n  }\n\n  // Blend the image into the canvas\n  Mix.blend(false, false, img);\n}\n","import { Mix, isMixReady, Cwidth, Cheight, State } from \"./color.js\";\nimport { randInt, noise, rr, sin, cos, cloneArray } from \"./utils.js\";\n\n// =============================================================================\n// Section: Matrix transformations\n// =============================================================================\n\n/**\n * The `Matrix` object stores the current translation offsets (`x` and `y`)\n * applied to the canvas. These values are updated whenever a translation\n * operation is performed.\n */\nexport const Matrix = { x: 0, y: 0 };\n\n/**\n * Translates the canvas by the specified x and y offsets.\n * Updates the `Matrix` object to reflect the current translation state.\n *\n * @param {number} x - The horizontal translation offset.\n * @param {number} y - The vertical translation offset.\n */\nexport function translate(x, y) {\n  isFieldReady();\n  Mix.ctx.translate(x, y); // Apply the translation to the canvas context\n  // Update the Matrix object with the current transformation state\n  let m = Mix.ctx.getTransform();\n  Matrix.x = m.e; // Horizontal offset\n  Matrix.y = m.f; // Vertical offset\n}\n\n/**\n * Rotates the canvas by the specified angle.\n *\n * @param {number} [a=0] - The angle of rotation in radians (default: 0).\n */\nexport function rotate(a = 0) {\n  isFieldReady();\n  Mix.ctx.rotate(a); // Apply the rotation to the canvas context\n}\n\n/**\n * Scales the canvas by the specified factor.\n *\n * @param {number} a - The scaling factor. Values greater than 1 enlarge the canvas,\n *                     while values between 0 and 1 shrink it.\n */\nexport function scale(a) {\n  isFieldReady();\n  Mix.ctx.scale(a, a); // Apply the scaling transformation to the canvas context\n}\n\n// =============================================================================\n// Section: Field Initialization\n// =============================================================================\n\nlet isLoaded = false;\n\n/**\n * Ensures the field system is initialized and ready for use.\n * If the field is not loaded, it initializes the mixing system and creates the field.\n */\nexport function isFieldReady() {\n  if (!isLoaded) {\n    isMixReady(); // Ensure the mixing system is ready\n    createField(); // Initialize the field\n    isLoaded = true;\n  }\n}\n\n// =============================================================================\n// Section: Position Class\n// =============================================================================\n\n/**\n * The Position class represents a point within a two-dimensional space, which can interact with a vector field.\n * It provides methods to update the position based on the field's flow and to check whether the position is\n * within certain bounds (e.g., within the field or canvas).\n */\nexport class Position {\n  /**\n   * Constructs a new Position instance.\n   * @param {number} x - The initial x-coordinate.\n   * @param {number} y - The initial y-coordinate.\n   */\n  constructor(x, y) {\n    this.update(x, y);\n    this.plotted = 0; // Tracks the total distance plotted\n  }\n\n  /**\n   * Updates the position's coordinates and calculates its offsets and indices within the flow field.\n   * @param {number} x - The new x-coordinate.\n   * @param {number} y - The new y-coordinate.\n   */\n  update(x, y) {\n    this.x = x;\n    this.y = y;\n    this.column_index = Position.getColIndex(x);\n    this.row_index = Position.getRowIndex(y);\n  }\n\n  /**\n   * Resets the 'plotted' property to 0.\n   */\n  reset() {\n    this.plotted = 0;\n  }\n\n  /**\n   * Checks if the position is within the active flow field's bounds.\n   * @returns {boolean} - True if the position is within the flow field, false otherwise.\n   */\n  isIn() {\n    return State.field.isActive\n      ? Position.isIn(this.column_index, this.row_index)\n      : this.isInCanvas(this.x, this.y);\n  }\n\n  /**\n   * Checks if the position is within the canvas bounds (with a margin).\n   * @returns {boolean} - True if the position is within bounds, false otherwise.\n   */\n  isInCanvas() {\n    const margin = 0.3;\n    const w = Cwidth;\n    const h = Cheight;\n    const x = this.x + Matrix.x;\n    const y = this.y + Matrix.y;\n    return (\n      x >= -margin * w &&\n      x <= (1 + margin) * w &&\n      y >= -margin * h &&\n      y <= (1 + margin) * h\n    );\n  }\n\n  /**\n   * Calculates the angle of the flow field at the position's current coordinates.\n   * @returns {number} - The angle in radians, or 0 if the position is not in the flow field or if the flow field is not active.\n   */\n  angle() {\n    return this.isIn() && State.field.isActive\n      ? flow_field()[this.column_index][this.row_index]\n      : 0;\n  }\n\n  /**\n   * Moves the position along the flow field by a certain length.\n   * @param {number} _length - The length to move along the field.\n   * @param {number} _dir - The direction of movement.\n   * @param {number} _step_length - The length of each step.\n   * @param {boolean} isFlow - Whether to use the flow field for movement.\n   */\n  moveTo(_length, _dir, _step_length, isFlow = true) {\n    if (!this.isIn()) {\n      this.plotted += _step_length;\n      return;\n    }\n\n    let a, b;\n    for (let i = 0; i < _length / _step_length; i++) {\n      if (isFlow) {\n        const angle = this.angle();\n        a = cos(angle - _dir);\n        b = sin(angle - _dir);\n      } else {\n        a = cos(-_dir);\n        b = sin(-_dir);\n      }\n      const x_step = _step_length * a;\n      const y_step = _step_length * b;\n      this.plotted += _step_length;\n      this.update(this.x + x_step, this.y + y_step);\n    }\n  }\n\n  /**\n   * Plots a point to another position within the flow field, following a Plot object\n   * @param {Position} _plot - The Plot path object.\n   * @param {number} _length - The length to move towards the target position.\n   * @param {number} _step_length - The length of each step.\n   * @param {number} _scale - The scaling factor for the plotting path.\n   */\n  plotTo(_plot, _length, _step_length, _scale) {\n    if (!this.isIn()) {\n      this.plotted += _step_length / _scale;\n      return;\n    }\n\n    const inverse_scale = 1 / _scale;\n    for (let i = 0; i < _length / _step_length; i++) {\n      const current_angle = this.angle();\n      const plot_angle = _plot.angle(this.plotted);\n      const x_step = _step_length * cos(current_angle - plot_angle);\n      const y_step = _step_length * sin(current_angle - plot_angle);\n      this.plotted += _step_length * inverse_scale;\n      this.update(this.x + x_step, this.y + y_step);\n    }\n  }\n\n  // Static Methods\n\n  /**\n   * Gets the row index for a given y-coordinate.\n   * @param {number} y - The y-coordinate.\n   * @returns {number} - The row index.\n   */\n  static getRowIndex(y, d = 1) {\n    const y_offset = y + Matrix.y - top_y;\n    return Math.round(y_offset / resolution / d);\n  }\n\n  /**\n   * Gets the column index for a given x-coordinate.\n   * @param {number} x - The x-coordinate.\n   * @returns {number} - The column index.\n   */\n  static getColIndex(x, d = 1) {\n    const x_offset = x + Matrix.x - left_x;\n    return Math.round(x_offset / resolution / d);\n  }\n\n  /**\n   * Checks if a column and row index are within the flow field bounds.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {boolean} - True if the indices are within bounds, false otherwise.\n   */\n  static isIn(col, row) {\n    return col >= 0 && row >= 0 && col < num_columns && row < num_rows;\n  }\n}\n\n// =============================================================================\n// Section: VectorField\n// =============================================================================\n\n/**\n * Represents the state of the vector field.\n * @property {boolean} isActive - Indicates if the vector field is active.\n * @property {string|null} current - The name of the currently active vector field.\n */\nState.field = {\n  isActive: false,\n  current: null,\n};\n\n// Internal variables for field configuration\nlet list = new Map();\nlet resolution, left_x, top_y, num_columns, num_rows;\n\n/**\n * Initializes the field grid and sets up the vector field's structure based on the renderer's dimensions.\n */\nexport function createField() {\n  resolution = Cwidth * 0.01; // Determine the resolution of the field grid\n  left_x = -0.5 * Cwidth; // Left boundary of the field\n  top_y = -0.5 * Cheight; // Top boundary of the field\n  num_columns = Math.round((2 * Cwidth) / resolution); // Number of columns in the grid\n  num_rows = Math.round((2 * Cheight) / resolution); // Number of columns in the grid\n  addStandard(); // Add default vector field\n  BleedField.genField(); // Generate the bleed field for watercolor fills\n}\n\n/**\n * Retrieves the field values for the current vector field.\n * @returns {Float32Array[]} The current vector field grid.\n */\nfunction flow_field() {\n  return list.get(State.field.current).field;\n}\n\n/**\n * Regenerates the current vector field using its associated generator function.\n * @param {number} [t=0] - An optional time parameter that can affect field generation.\n */\nexport function refreshField(t = 0) {\n  list.get(State.field.current).field = list\n    .get(State.field.current)\n    .gen(t, genField());\n}\n\n/**\n * Generates an empty field array.\n * Reuses existing arrays to reduce memory allocation overhead.\n * @returns {Float32Array[]} Empty vector field grid.\n */\nfunction genField(d = 1) {\n  return new Array(num_columns / d)\n    .fill(null)\n    .map(() => new Float32Array(num_rows / d));\n}\n\n/**\n * Activates a specific vector field by name, ensuring it's ready for use.\n * @param {string} a - The name of the vector field to activate.\n */\nexport function field(a) {\n  if (!list.has(a)) {\n    throw new Error(`Field \"${name}\" does not exist.`);\n  }\n  State.field.isActive = true; // Mark the field framework as active\n  State.field.current = a; // Update the current field\n}\n\n/**\n * Deactivates the current vector field.\n */\nexport function noField() {\n  State.field.isActive = false;\n}\n\n/**\n * Adds a new vector field to the field list with a unique name and a generator function.\n * @param {string} name - The unique name for the new vector field.\n * @param {Function} funct - The function that generates the field values.\n */\nexport function addField(name, funct) {\n  list.set(name, { gen: funct }); // Map the field name to its generator function\n  list.get(name).field = list.get(name).gen(0, genField()); // Generate the initial field\n}\n\n/**\n * Retrieves a list of all available vector field names.\n * @returns {string[]} An array of all the field names.\n */\nexport function listFields() {\n  return Array.from(list.keys());\n}\n\n/**\n * Adds standard predefined vector fields to the list with unique behaviors.\n */\nfunction addStandard() {\n  addField(\"hand\", function (t, field) {\n    const baseSize = rr(0.2, 0.8);\n    const baseAngle = randInt(5, 10);\n    const timeFactor = t * 0.1;\n\n    for (let column = 0; column < num_columns; column++) {\n      const columnNoise = column * 0.1 + timeFactor;\n      for (let row = 0; row < num_rows; row++) {\n        const addition = randInt(15, 25);\n        const angle = baseAngle * sin(baseSize * row * column + addition);\n        const noise_val = noise(columnNoise, row * 0.1 + timeFactor);\n        field[column][row] = 0.5 * angle * cos(t) + noise_val * baseAngle * 0.5;\n      }\n    }\n    return field;\n  });\n  addField(\"seabed\", function (t, field) {\n    const baseSize = rr(0.4, 0.8);\n    const baseAngle = randInt(18, 26);\n    const timeFactor = t * 0.1;\n\n    for (let column = 0; column < num_columns; column++) {\n      const columnNoise = column * 0.1 + timeFactor;\n      for (let row = 0; row < num_rows; row++) {\n        const addition = randInt(15, 20);\n        const angle = baseAngle * sin(baseSize * row * column + addition);\n        field[column][row] = 1.1 * angle * cos(t);\n      }\n    }\n    return field;\n  });\n}\n\n// =============================================================================\n// Section: BleedField\n// =============================================================================\n\n/**\n * The `BleedField` object manages a secondary field used for blending effects,\n * such as watercolor-like bleeding. It provides methods to generate, update,\n * and retrieve field values.\n */\nexport const BleedField = {\n\n  d: 4, // The density of the bleed field\n\n  /**\n   * Generates the primary and temporary fields for the bleed effect.\n   * Reuses existing arrays to reduce memory allocation overhead.\n   */\n  genField() {\n    this.field = genField(this.d); // Primary field\n    this.fieldTemp = genField(this.d); // Temporary field for intermediate calculations\n  },\n\n  /**\n   * Retrieves the value of the bleed field at a specific position.\n   * Optionally updates the field with a new value.\n   *\n   * @param {number} x - The x-coordinate.\n   * @param {number} y - The y-coordinate.\n   * @param {number} [value=false] - The value to set at the position (optional).\n   * @returns {number} - The current or updated value at the position.\n   */\n  get(x, y, value = false) {\n    const col = Position.getColIndex(x, this.d);\n    const row = Position.getRowIndex(y, this.d);\n    // Retrieve the current value at the position\n    const current = this.field?.[col]?.[row] ?? 0;\n    if (value) {\n      // Update the temporary field with the maximum of the current and new values\n      const biggest = Math.max(current, value);\n      const tempValue = (current === 0 ? 0 : this.fieldTemp[col][row]) * 0.75;\n      this.fieldTemp[col][row] = Math.max(biggest, tempValue);\n      return biggest;\n    }\n    return current;\n  },\n\n  /**\n   * Updates the primary field with the values from the temporary field.\n   * This operation is performed in-place to avoid unnecessary memory allocation.\n   */\n  update() {\n    for (let col = 0; col < num_columns / this.d; col++) {\n      for (let row = 0; row < num_rows / this.d; row++) {\n        this.field[col][row] = this.fieldTemp[col][row];\n      }\n    }\n  },\n\n  /**\n   * Saves the current state of the primary and temporary fields.\n   * This allows the fields to be restored later.\n   */\n  save() {\n    this.A = cloneArray(this.field);\n    this.B = cloneArray(this.fieldTemp);\n  },\n\n  /**\n   * Restores the previously saved state of the primary and temporary fields.\n   */\n  restore() {\n    this.field = this.A;\n    this.fieldTemp = this.B;\n  },\n};\n","import { Mix, State } from \"./color.js\";\nimport { Matrix, BleedField, isFieldReady } from \"./flowfield.js\";\n\n// =============================================================================\n// SAVE / RESTORE\n// =============================================================================\n\n/**\n * Object that holds the saved brush state for push/pop operations.\n * @type {Object}\n */\nlet _saveState = {};\n\n/**\n * Saves the current state from the State and BleedField objects.\n * It also saves the current canvas context state.\n */\nexport function save() {\n  // Ensure the field is ready before saving\n  isFieldReady();\n\n  // Save the canvas context\n  Mix.ctx.save();\n\n  // Save a copy of the current state\n  _saveState.fill = { ...State.fill };\n  _saveState.stroke = { ...State.stroke };\n  _saveState.hatch = { ...State.hatch };\n  _saveState.field = { ...State.field };\n\n  // Save additional field state\n  BleedField.save();\n}\n\n/**\n * Restores the saved state from the _saveState object.\n * It also restores the canvas context state.\n */\nexport function restore() {\n  // Restore the canvas context\n  Mix.ctx.restore();\n\n  // Update Matrix transform from the current context\n  let m = Mix.ctx.getTransform();\n  Matrix.x = m.e;\n  Matrix.y = m.f;\n\n  // Restore State from saved copies\n  State.stroke = { ..._saveState.stroke };\n  State.field = { ..._saveState.field };\n  State.hatch = { ..._saveState.hatch };\n  State.fill = { ..._saveState.fill };\n\n  // Restore additional field state\n  BleedField.restore();\n}\n","import { Mix } from \"./color.js\";\n\n// =============================================================================\n// Section: Draw shapes to Mask Buffer\n// =============================================================================\n\n/**\n * Draws a polygon to the mask using the provided vertices.\n * @param {Array<{x: number, y: number}>} vertices - Array of vertex coordinates.\n */\nexport function drawPolygon(vertices) {\n  Mix.ctx.beginPath();\n  vertices.forEach((v, i) => {\n    if (i === 0) Mix.ctx.moveTo(v.x, v.y);\n    else Mix.ctx.lineTo(v.x, v.y);\n  });\n  Mix.ctx.closePath();\n}\n\n/**\n * Draws a rectangle to the mask.\n * @param {number} x - X-coordinate of the rectangle's center.\n * @param {number} y - Y-coordinate of the rectangle's center.\n * @param {number} d - Diameter of the rectangle.\n */\nexport function rect(x, y, d) {\n  const size = d / 1.2;\n  Mix.ctx.rect(x - size / 2, y - size / 2, size, size);\n}\n\n/**\n * Draws a circle to the mask.\n * @param {number} x - X-coordinate of the circle's center.\n * @param {number} y - Y-coordinate of the circle's center.\n * @param {number} d - Diameter of the circle.\n */\nexport function circle(x, y, d) {\n  const PI2 = Math.PI * 2;\n  const radius = d / 2;\n  Mix.ctx.moveTo(x + radius, y);\n  Mix.ctx.arc(x, y, radius, 0, PI2);\n}\n","import { Color } from \"./color.js\";\nimport { drawPolygon } from \"./mask.js\";\n\n// =============================================================================\n// Erase Functions\n// =============================================================================\n/**\n * This module provides functions to handle erasing operations. It uses the\n * blending system to erase parts of the canvas by applying a mask with a\n * specified color and transparency.\n */\n\nexport const E = {\n  isActive: false, // Tracks if erasing is active\n  c: null, // Current erase color\n  a: 255, // Current erase alpha (transparency)\n};\n\n/**\n * Activates the erase mode with a specified color and alpha.\n * @param {string|Color} color - The erase color (default: background color).\n * @param {number} alpha - The transparency level (0-255, default: 255).\n */\nexport function erase(color = _bg_Color, alpha = 255) {\n  E.isActive = true;\n  E.c = new Color(color);\n  E.a = alpha;\n}\n\n/**\n * Deactivates the erase mode.\n */\nexport function noErase() {\n  E.isActive = false;\n}\n\n/**\n * Draws an erase operation using a polygon mask.\n * @param {Array<{x: number, y: number}>} vertices - The vertices of the polygon to erase.\n */\nexport function drawErase(vertices) {\n  // Set the blending color and activate erase mode\n  Mix.blend(E.c);\n  Mix.isErase = true;\n  // Save the current context state\n  Mix.ctx.save();\n  // Set the fill style with the erase alpha\n  Mix.ctx.fillStyle = \"rgb(255 0 0 / \" + E.a + \"%)\";\n  // Draw the polygon mask\n  drawPolygon(vertices);\n  // Fill the mask and restore the context state\n  Mix.ctx.fill();\n  Mix.ctx.restore();\n}\n","import { State } from \"./color.js\";\nimport { intersectLines } from \"./utils.js\";\nimport { E, drawErase } from \"./erase.js\";\n\n// =============================================================================\n// Section: Polygon Class\n// =============================================================================\n\n/**\n * Represents a polygon with a set of vertices and provides methods for\n * intersection, drawing, filling, and hatching.\n */\nexport class Polygon {\n  /**\n   * Constructs the Polygon object from an array of points.\n   * @param {Array} pointsArray - An array of points, where each point is an array of two numbers [x, y].\n   * @param {boolean} [useRawVertices=false] - If true, uses the raw array as vertices.\n   */\n  constructor(pointsArray, useRawVertices = false) {\n    this.a = pointsArray;\n    this.vertices = useRawVertices\n      ? pointsArray\n      : pointsArray.map(([x, y]) => ({ x, y }));\n    this.sides = this.vertices.map((v, i, arr) => [\n      v,\n      arr[(i + 1) % arr.length],\n    ]);\n    this._intersectionCache = {}; // Cache for intersection results\n  }\n\n  /**\n   * Intersects a given line with the polygon, returning all intersection points.\n   * @param {Object} line - The line to intersect with the polygon, having two properties 'point1' and 'point2'.\n   * @returns {Array} An array of intersection points (each with 'x' and 'y' properties) or an empty array if no intersections.\n   */\n  intersect(line) {\n    // Check if the result has been cached\n    const cacheKey = `${line.point1.x},${line.point1.y}-${line.point2.x},${line.point2.y}`;\n    if (this._intersectionCache[cacheKey]) {\n      return this._intersectionCache[cacheKey];\n    }\n    const points = [];\n    for (const [start, end] of this.sides) {\n      const intersection = intersectLines(line.point1, line.point2, start, end);\n      if (intersection) points.push(intersection);\n    }\n    this._intersectionCache[cacheKey] = points; // Cache the result\n    return points;\n  }\n\n  /**\n   * Erases the polygon using the erase tool.\n   */\n  erase() {\n    if (E.isActive) drawErase(this.vertices);\n  }\n\n  /**\n   * Displays the polygon with optional stroke, hatch, and fill effects.\n   */\n  show() {\n    if (State.draw) this.draw();\n    if (State.hatch) this.hatch();\n    if (State.fill) this.fill();\n    this.erase();\n  }\n}\n","import { State } from \"./color.js\";\nimport { toDegrees, map, rr } from \"./utils.js\";\nimport { Position, isFieldReady } from \"./flowfield.js\";\nimport { E, drawErase } from \"./erase.js\";\nimport { Polygon } from \"./polygon.js\";\n\n// =============================================================================\n// Section: Plot Class\n// =============================================================================\n\n/**\n * The Plot class represents a collection of segments that define shapes or paths.\n * It supports operations like adding segments, calculating angles and pressures,\n * and generating polygons based on the plot's structure.\n */\nexport class Plot {\n  /**\n   * Creates a new Plot.\n   * @param {string} _type - The type of plot, \"curve\" or \"segments\".\n   */\n  constructor(_type) {\n    this.segments = [];\n    this.angles = [];\n    this.pres = [];\n    this.type = _type;\n    this.dir = 0;\n    this.calcIndex(0);\n    this.pol = false;\n  }\n\n  /**\n   * Adds a segment to the plot with specified angle, length, and pressure.\n   * @param {number} _a - The angle of the segment.\n   * @param {number} _length - The length of the segment.\n   * @param {number} _pres - The pressure of the segment.\n   * @param {boolean} _degrees - Whether the angle is in degrees.\n   */\n  addSegment(_a = 0, _length = 0, _pres = 1, _degrees = false) {\n    if (this.angles.length > 0) this.angles.pop(); // Remove the last angle\n    _a = _degrees ? ((_a % 360) + 360) % 360 : toDegrees(_a); // Normalize angle\n    this.angles.push(_a, _a); // Push angle twice for continuity\n    this.pres.push(_pres);\n    this.segments.push(_length);\n    this.length = this.segments.reduce((sum, len) => sum + len, 0); // Update total length\n  }\n\n  /**\n   * Finalizes the plot by setting the last angle and pressure.\n   * @param {number} _a - The final angle.\n   * @param {number} _pres - The final pressure.\n   * @param {boolean} _degrees - Whether the angle is in degrees.\n   */\n  endPlot(_a = 0, _pres = 1, _degrees = false) {\n    _a = _degrees ? ((_a % 360) + 360) % 360 : toDegrees(_a);\n    this.angles[this.angles.length - 1] = _a; // Update the last angle\n    this.pres.push(_pres);\n  }\n\n  /**\n   * Rotates the entire plot by a given angle.\n   * @param {number} _a - The angle to rotate the plot.\n   */\n  rotate(_a) {\n    this.dir = toDegrees(_a);\n  }\n\n  /**\n   * Calculates the pressure at a given distance along the plot.\n   * @param {number} _d - The distance along the plot.\n   * @returns {number} - The interpolated pressure.\n   */\n  pressure(_d) {\n    // If the distance exceeds the plot length, return the last pressure\n    if (_d > this.length) return this.pres[this.pres.length - 1];\n    // Otherwise, calculate the pressure using the curving function\n    return this.curving(this.pres, _d);\n  }\n\n  /**\n   * Calculates the angle at a given distance along the plot.\n   * @param {number} _d - The distance along the plot.\n   * @returns {number} - The calculated angle.\n   */\n  angle(_d) {\n    // If the distance exceeds the plot length, return the last angle\n    if (_d > this.length) return this.angles[this.angles.length - 1];\n    // Calculate the index for the given distance\n    this.calcIndex(_d);\n    // Return the angle, adjusted for the plot type and direction\n    return this.type === \"curve\"\n      ? this.curving(this.angles, _d) + this.dir\n      : this.angles[this.index] + this.dir;\n  }\n\n  /**\n   * Interpolates values between segments for smooth transitions.\n   * @param {Array<number>} array - The array to interpolate within.\n   * @param {number} _d - The distance along the plot.\n   * @returns {number} - The interpolated value.\n   */\n  curving(array, _d) {\n    let map0 = array[this.index];\n    let map1 = array[this.index + 1] ?? map0;\n    if (Math.abs(map1 - map0) > 180) {\n      if (map1 > map0) map1 = -(360 - map1);\n      else map0 = -(360 - map0);\n    }\n    return map(_d - this.suma, 0, this.segments[this.index], map0, map1, true);\n  }\n\n  /**\n   * Calculates the current index of the plot based on the distance.\n   * @param {number} _d - The distance along the plot.\n   */\n  calcIndex(_d) {\n    this.index = -1;\n    this.suma = 0;\n    let d = 0;\n    while (d <= _d) {\n      this.suma = d;\n      d += this.segments[this.index + 1];\n      this.index++;\n    }\n    return this.index;\n  }\n\n  /**\n   * Generates a polygon based on the plot.\n   * @param {number} _x - The x-coordinate for the starting point.\n   * @param {number} _y - The y-coordinate for the starting point.\n   * @param {number} _scale - The scale factor for the polygon.\n   * @param {number} _side - The side factor for the polygon.\n   * @returns {Polygon} - The generated polygon.\n   */\n  genPol(_x, _y, _scale = 1, _side) {\n    isFieldReady(); // Ensure that the drawing environment is prepared\n    const step = 0.5;\n    const vertices = [];\n    const numSteps = Math.round(this.length / step);\n    const pos = new Position(_x, _y);\n    let pside = 0;\n    let prevIdx = 0;\n\n    for (let i = 0; i < numSteps; i++) {\n      pos.plotTo(this, step, step, 1);\n      const idx = this.calcIndex(pos.plotted);\n      pside += step;\n      const maxSize = Math.max(this.segments[idx] * _side * rr(0.7, 1.3),10);\n      if (\n        (pside >= maxSize ||\n          idx >= prevIdx) &&\n        pos.x\n      ) {\n        vertices.push([pos.x, pos.y]);\n        pside = 0;\n        if (idx >= prevIdx) prevIdx++;\n      }\n    }\n    return new Polygon(vertices);\n  }\n\n  /**\n   * Erases the plot using the erase tool.\n   * @param {number} x - The x-coordinate.\n   * @param {number} y - The y-coordinate.\n   * @param {number} scale - The scale factor.\n   */\n  erase(x, y, scale) {\n    if (E.isActive) {\n      if (this.origin) [x, y, scale] = [...this.origin, 1];\n      this.pol = this.genPol(x, y, scale, 0.15);\n      drawErase(this.pol.vertices);\n    }\n  }\n\n  /**\n   * Displays the plot with optional stroke, hatch, and fill effects.\n   * @param {number} x - The x-coordinate.\n   * @param {number} y - The y-coordinate.\n   * @param {number} scale - The scale factor.\n   */\n  show(x, y, scale = 1) {\n    if (State.stroke) this.draw(x, y, scale);\n    if (State.hatch) this.hatch(x, y, scale);\n    if (State.fill) this.fill(x, y, scale);\n    this.erase(x, y, scale);\n  }\n}\n","import {\n  rr,\n  randInt,\n  sin,\n  cos,\n  toDegrees,\n  constrain,\n  dist,\n  calcAngle,\n  intersectLines,\n} from \"./utils.js\";\nimport { Polygon } from \"./polygon.js\";\nimport { Plot } from \"./plot.js\";\n\n// =============================================================================\n// Section: Primitives and Geommetry\n// =============================================================================\n\n/**\n * Creates a Polygon from an array of points and calls its show() method.\n * @param {Array<Array<number>>} pointsArray - Array of points [x, y, pressure]\n */\nexport function polygon(pointsArray) {\n  // Create a new Polygon instance\n  const polygon = new Polygon(pointsArray);\n  polygon.show();\n}\n\n/**\n * Draws a rectangle on the canvas using path functions.\n * @param {number} x - X-coordinate.\n * @param {number} y - Y-coordinate.\n * @param {number} w - Width.\n * @param {number} h - Height.\n * @param {boolean} [mode=\"corner\"] - \"corner\" (default) or \"center\".\n */\nexport function rect(x, y, w, h, mode = \"corner\") {\n  if (mode === \"center\") {\n    x -= w / 2;\n    y -= h / 2;\n  }\n  beginPath(0);\n  moveTo(x, y);\n  lineTo(x + w, y);\n  lineTo(x + w, y + h);\n  lineTo(x, y + h);\n  closePath();\n  endPath();\n}\n\n/**\n * Draws a circle on the canvas.\n * @param {number} x - Center x.\n * @param {number} y - Center y.\n * @param {number} radius - Circle radius.\n * @param {boolean} [r=false] - Randomizes segment lengths if true.\n */\nexport function circle(x, y, radius, r = false) {\n  const p = new Plot(\"curve\");\n  const arcLength = Math.PI * radius;\n  const angleOffset = rr(0, 360);\n  const randomFactor = r ? () => 1 + 0.2 * rr() : () => 1;\n\n  // Divide circle into 4 segments\n  for (let i = 0; i < 4; i++) {\n    const angle = -90 * i + angleOffset;\n    p.addSegment(\n      angle * randomFactor(),\n      (arcLength / 2) * randomFactor(),\n      1,\n      true\n    );\n  }\n\n  // Optionally add a random final angle for the last segment\n  if (r) {\n    const randomAngle = randInt(-5, 5);\n    p.addSegment(\n      angleOffset,\n      Math.abs(randomAngle) * (Math.PI / 180) * radius,\n      1,\n      true\n    );\n    p.endPlot(randomAngle + angleOffset, 1, true);\n  } else {\n    p.endPlot(angleOffset, 1, true);\n  }\n\n  // Draw the circle\n  const offsetX = x - radius * sin(angleOffset);\n  const offsetY = y - radius * cos(-angleOffset);\n  p.show(offsetX, offsetY, 1);\n}\n\n/**\n * Draws an arc on the canvas.\n * @param {number} x - Center x.\n * @param {number} y - Center y.\n * @param {number} radius - Radius.\n * @param {number} start - Radian start angle.\n * @param {number} end - Radian end angle.\n */\nexport function arc(x, y, radius, start, end) {\n  const p = new Plot(\"curve\");\n  const startAngle = 270 - toDegrees(start);\n  const endAngle = 270 - toDegrees(end);\n  const arcAngle = toDegrees(end - start);\n  const arcLength = (Math.PI * radius * arcAngle) / 180;\n\n  p.addSegment(startAngle, arcLength, 1, true);\n  p.endPlot(endAngle, 1, true);\n\n  const startX = x + radius * cos(-startAngle - 90);\n  const startY = y + radius * sin(-startAngle - 90);\n  p.draw(startX, startY, 1);\n}\n\n// Variables for managing paths and strokes\nlet _pathArray;\nlet _current;\nlet _curvature;\n\nclass SubPath {\n  constructor() {\n    this.isClosed = false;\n    this.curvature = _curvature;\n    this.vert = [];\n  }\n  /**\n   * Adds a vertex to this subpath.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} pressure\n   */\n  vertex(x, y, pressure) {\n    this.vert.push([x, y, pressure]);\n  }\n  /**\n   * Renders the subpath by creating a spline from its vertices.\n   */\n  show() {\n    let plot = _createSpline(this.vert, this.curvature, this.isClosed);\n    plot.show();\n  }\n}\n\n/**\n * Begins a new path with a specified curvature.\n * @param {number} [curvature=0] - Curvature from 0 to 1.\n */\nexport function beginPath(curvature = 0) {\n  _curvature = constrain(curvature, 0, 1);\n  _pathArray = [];\n}\n\n/**\n * Moves to a new point in the current path.\n * @param {number} x - X-coordinate.\n * @param {number} y - Y-coordinate.\n * @param {number} [pressure=1] - Pressure value.\n */\nexport function moveTo(x, y, pressure = 1) {\n  _current = new SubPath();\n  _pathArray.push(_current);\n  _current.vertex(x, y, pressure);\n}\n\n/**\n * Adds a line segment from the current point to the given coordinates.\n * @param {number} x - Destination x.\n * @param {number} y - Destination y.\n * @param {number} [pressure=1] - Pressure value.\n */\nexport function lineTo(x, y, pressure = 1) {\n  _current.vertex(x, y, pressure);\n}\n\n/**\n * Closes the current path by connecting the last point to the first.\n */\nexport function closePath() {\n  _current.vertex(..._current.vert[0]);\n  _current.isClosed = true;\n}\n\n/**\n * Ends the current path and renders all subpaths.\n */\nexport function endPath() {\n  for (let sub of _pathArray) {\n    sub.show();\n  }\n  _pathArray = false;\n}\n\nlet _strokeArray, _strokeOrigin;\n\n/**\n * Begins a new stroke with a given type and starting position.\n * @param {string} type - Stroke type.\n * @param {number} x - Starting x.\n * @param {number} y - Starting y.\n */\nexport function beginStroke(type, x, y) {\n  _strokeOrigin = [x, y]; // Store the starting position for later use\n  _strokeArray = new Plot(type); // Initialize a new Plot with the specified type\n}\n\n/**\n * Adds a segment to the stroke.\n * @param {number} angle - Segment angle.\n * @param {number} length - Segment length.\n * @param {number} pressure - Segment pressure.\n */\nexport function move(angle, length, pressure) {\n  _strokeArray.addSegment(angle, length, pressure); // Add the new segment to the Plot\n}\n\n/**\n * Completes and renders the stroke.\n * @param {number} angle - End angle.\n * @param {number} pressure - End pressure.\n */\nexport function endStroke(angle, pressure) {\n  _strokeArray.endPlot(angle, pressure); // Finalize the Plot with the end angle and pressure\n  _strokeArray.draw(_strokeOrigin[0], _strokeOrigin[1], 1); // Draw the stroke using the stored starting position\n  _strokeArray = false; // Clear the _strokeArray to indicate the end of this stroke\n}\n\n/**\n * Creates and draws a spline curve from an array of points.\n * @param {Array<Array<number>>} array_points - Array of points [x, y, pressure].\n * @param {number} [curvature=0.5] - Curvature from 0 to 1.\n */\nexport function spline(_array_points, _curvature = 0.5) {\n  let p = _createSpline(_array_points, _curvature); // Create a new Plot-spline instance\n  p.draw(); // Draw the Plot\n}\n\n/**\n * Creates a new Plot object representing a spline curve.\n *\n * For curved segments (curvature > 0) with at least 3 points available,\n * the function either treats segments as straight (if their angles match)\n * or calculates control points to compute a circular arc.\n *\n * If no curvature is specified, a simple straight segment is used.\n *\n * @param {Array<Array<number>>} points - Array of points [x, y, pressure].\n * @param {number} [curvature=0.5] - Curvature value between 0 and 1.\n * @param {boolean} [close=false] - Whether to close the spline.\n * @returns {Plot} - The generated Plot object.\n */\nfunction _createSpline(points, curvature = 0.5, close = false) {\n  const plotType = curvature === 0 ? \"segments\" : \"curve\";\n  const p = new Plot(plotType);\n  const PI2 = Math.PI * 2;\n\n  // If closing the spline, add the second point to the end\n  if (close && curvature !== 0) {\n    points.push(points[1]);\n  }\n\n  if (points && points.length > 0) {\n    let done = 0; // Tracks excess length from previous segment\n    let pep, tep, pep2; // Variables used for initial calibration\n\n    for (let i = 0; i < points.length - 1; i++) {\n      // For curved segments (if curvature > 0 and there is at least 3 points ahead)\n      if (curvature > 0 && i < points.length - 2) {\n        const p1 = points[i];\n        const p2 = points[i + 1];\n        const p3 = points[i + 2];\n\n        const d1 = dist(p1[0], p1[1], p2[0], p2[1]);\n        const d2 = dist(p2[0], p2[1], p3[0], p3[1]);\n        const a1 = calcAngle(p1[0], p1[1], p2[0], p2[1]);\n        const a2 = calcAngle(p2[0], p2[1], p3[0], p3[1]);\n\n        // Compute the adjustment length based on curvature\n        const curvAdjust = curvature * Math.min(d1, d2, 0.5 * Math.min(d1, d2));\n        const dmax = Math.max(d1, d2);\n        const s1 = d1 - curvAdjust;\n        const s2 = d2 - curvAdjust;\n\n        if (Math.floor(a1) === Math.floor(a2)) {\n          // If angles are nearly the same, treat as a straight segment\n          const temp = close ? (i === 0 ? 0 : d1 - done) : d1 - done;\n          const temp2 = close ? (i === 0 ? 0 : d2 - pep2) : d2;\n\n          p.addSegment(a1, temp, p1[2], true);\n          if (i === points.length - 3) {\n            p.addSegment(a2, temp2, p2[2], true);\n          }\n\n          done = 0;\n          if (i === 0) {\n            pep = d1;\n            pep2 = curvAdjust;\n            tep = points[1];\n            done = 0;\n          }\n        } else {\n          // For a curved segment, compute control points and arc segment details\n          const point1 = {\n            x: p2[0] - curvAdjust * cos(-a1),\n            y: p2[1] - curvAdjust * sin(-a1),\n          };\n          const point2 = {\n            x: point1.x + dmax * cos(-a1 + 90),\n            y: point1.y + dmax * sin(-a1 + 90),\n          };\n          const point3 = {\n            x: p2[0] + curvAdjust * cos(-a2),\n            y: p2[1] + curvAdjust * sin(-a2),\n          };\n          const point4 = {\n            x: point3.x + dmax * cos(-a2 + 90),\n            y: point3.y + dmax * sin(-a2 + 90),\n          };\n\n          const intPt = intersectLines(point1, point2, point3, point4, true);\n          const radius = dist(point1.x, point1.y, intPt.x, intPt.y);\n          const halfDist = dist(point1.x, point1.y, point3.x, point3.y) / 2;\n          const arcAngle = 2 * Math.asin(halfDist / radius) * (180 / Math.PI);\n          const arcLength = (PI2 * radius * arcAngle) / 360;\n\n          const temp = close ? (i === 0 ? 0 : s1 - done) : s1 - done;\n          const temp2 =\n            i === points.length - 3 ? (close ? pep - curvAdjust : s2) : 0;\n\n          p.addSegment(a1, temp, p1[2], true);\n          p.addSegment(a1, isNaN(arcLength) ? 0 : arcLength, p1[2], true);\n          p.addSegment(a2, temp2, p2[2], true);\n\n          done = curvAdjust;\n          if (i === 0) {\n            pep = s1;\n            pep2 = curvAdjust;\n            tep = [point1.x, point1.y];\n          }\n        }\n\n        if (i === points.length - 3) {\n          p.endPlot(a2, p2[2], true);\n        }\n      } else if (curvature === 0) {\n        // If no curvature, add a simple straight segment\n        const p1 = points[i];\n        const p2 = points[i + 1];\n        const d = dist(p1[0], p1[1], p2[0], p2[1]);\n        const a = calcAngle(p1[0], p1[1], p2[0], p2[1]);\n\n        p.addSegment(a, d, p2[2], true);\n        if (i === points.length - 2) {\n          p.endPlot(a, 1, true);\n        }\n      }\n    }\n\n    p.origin = close && curvature !== 0 ? tep : points[0];\n  }\n\n  return p;\n}\n","import { Mix } from \"./color.js\";\n\n// =============================================================================\n// Section: Drawing Loop\n// =============================================================================\n\nlet _time = 0,\n  _isLoop = true,\n  _drawingLoop,\n  _fps = 30;\n\nexport let frameCount = 0;\n\n/**\n * Starts the drawing loop.\n * @param {Function} [drawingLoop] - Custom function to execute on each frame.\n */\nexport function loop(drawingLoop = false) {\n  if (drawingLoop) _drawingLoop = drawingLoop;\n  _isLoop = true;\n  requestAnimationFrame(drawLoop);\n}\n\n/**\n * Stops the drawing loop.\n */\nexport function noLoop() {\n  _isLoop = false;\n}\n\n/**\n * Gets or sets the frame rate.\n * @param {number} [fps] - Desired frames per second.\n * @returns {number} - Current frame rate.\n */\nexport let frameRate = (fps) => {\n  if (fps) _fps = fps;\n  return _fps;\n};\n\n/**\n * Main loop function. Executes the user-defined loop and composites the frame.\n * @param {number} timeStamp - Current time in milliseconds.\n */\nfunction drawLoop(timeStamp) {\n  if (_isLoop) {\n    if (timeStamp > _time + 1000 / frameRate() || timeStamp === 0) {\n      _time = timeStamp;\n      frameCount++;\n      if (_drawingLoop) _drawingLoop();\n      endFrame();\n    }\n  }\n  requestAnimationFrame(drawLoop);\n}\n\n/**\n * Use this function when you want to composite the final result\n */\nexport function endFrame() {\n  Mix.blend(false, true);\n}\n","// =============================================================================\n// Module: GL Draw\n// =============================================================================\n/**\n * The GL Draw module provides functions for rendering shapes (circles and squares)\n * using WebGL2. It initializes the WebGL context and shader programs, prepares buffers,\n * and implements drawing routines based on queued drawing primitives. The module uses\n * an orthographic projection to map canvas coordinates to clip space and supports adjustable\n * blending for translucent effects.\n */\n\nimport { Mix, Cwidth, Cheight } from \"../core/color.js\";\nimport { isMixReady } from \"../core/color.js\";\nimport { Matrix } from \"../core/flowfield.js\";\nimport { createProgram } from \"../core/gl/utils.js\";\n\n// =============================================================================\n// Section: Initialization and Setup\n// =============================================================================\n\nlet isLoaded = false;\nlet gl, matrix;\n\n/**\n * Initializes WebGL objects if not done already.\n */\nexport function isReady() {\n  if (!isLoaded) {\n    isMixReady();\n    gl = Mix.gl;\n    matrix = createOrthographicMatrix(Cwidth, Cheight);\n    prepareGL();\n    isLoaded = true;\n  }\n}\n\n/**\n * Creates an orthographic projection matrix that maps canvas coordinates to clip space.\n * @param {number} w - Canvas width.\n * @param {number} h - Canvas height.\n * @returns {Float32Array} The projection matrix.\n */\nfunction createOrthographicMatrix(w, h) {\n  return new Float32Array([\n    2 / w,\n    0,\n    0,\n    0,\n    0,\n    -2 / h,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    -1,\n    1,\n    0,\n    1,\n  ]);\n}\n\n/**\n * Sets up the shader program and caches attribute and uniform locations.\n */\nfunction prepareGL() {\n  // Create and use shader\n  const program = createProgram(gl, vsSource, fsSource);\n  gl.useProgram(program);\n  // Enable blending for translucency.\n  gl.enable(gl.BLEND);\n  // Use additive blending so that new fragments add to the alpha.\n  gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);\n  // Define attributes and uniform locations\n  [\"a_position\", \"a_radius\", \"a_alpha\"].forEach(\n    (n) => (Attr[n] = gl.getAttribLocation(program, n))\n  );\n  [\"u_matrix\", \"u_drawSquare\"].forEach(\n    (n) => (Frag[n] = gl.getUniformLocation(program, n))\n  );\n}\n\n// =============================================================================\n// Section: Shader Programs\n// =============================================================================\n\n/**\n * Vertex shader: Expects a_position (vec2), a_radius (float), and a_alpha (float).\n * Computes gl_Position from u_matrix and sets gl_PointSize.\n */\nconst vsSource = `#version 300 es\nin vec2 a_position;in float a_radius,a_alpha;uniform mat4 u_matrix;out float v_alpha;void main(){gl_Position=u_matrix*vec4(a_position,0,1);v_alpha=a_alpha;gl_PointSize=a_radius*2.;}`;\n\n/**\n * Fragment shader: When u_drawSquare is true, outputs a square.\n * Otherwise, uses gl_PointCoord to create a circular mask.\n */\nconst fsSource = `#version 300 es\nprecision highp float;uniform bool u_drawSquare;in float v_alpha;out vec4 outColor;void main(){if(u_drawSquare)outColor=vec4(vec3(1,0,0)*v_alpha,v_alpha);else{vec2 v=gl_PointCoord-vec2(.5);float e=length(v);if(e>.5)discard;outColor=vec4(vec3(1,0,0)*v_alpha,v_alpha*(1.-smoothstep(.45,.5,e)));}}`;\n\n// Attrib & uniform caches.\nconst Attr = {},\n  Frag = {};\n\n// =============================================================================\n// Section: Buffer Creation & Drawing Primitives\n// =============================================================================\n\n/**\n * Helper: Creates a VAO, uploads vertex data, and sets attribute pointers.\n * @param {Float32Array} data - Vertex data.\n * @param {Array} attribs - Array of objects {name, size, offset}.\n * @param {number} stride - Stride in bytes.\n * @returns {object} Contains {vao, buf}.\n */\nfunction createAndBindBuffer(data, attribs, stride) {\n  const vao = gl.createVertexArray();\n  gl.bindVertexArray(vao);\n  const buf = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n  attribs.forEach((a) => {\n    const loc = Attr[a.name];\n    gl.enableVertexAttribArray(loc);\n    gl.vertexAttribPointer(loc, a.size, gl.FLOAT, false, stride, a.offset);\n  });\n  return { vao, buf };\n}\n\n/**\n * Draws all queued circles (each with its own alpha) using WebGL2.\n *\n * This function builds a Float32Array containing four values per circle:\n *   [x, y, radius, alpha]\n *\n * The vertex shader (vsSource) expects:\n *   - a_position: a vec2 containing the x,y position for each circle.\n *   - a_radius: a float that is used to determine gl_PointSize (scaled by 2).\n *   - a_alpha: a float used to control the alpha (transparency) of the circle.\n *\n * The function then uploads this array into a vertex buffer and instructs WebGL\n * to draw the circles as GL_POINTS. The blending mode set in prepareGL() handles\n * translucency so that overlapping circles properly accumulate alpha.\n *\n * After drawing, the circles queue is cleared.\n */\nexport function glDraw() {\n  // Define the stride in bytes: 4 floats per circle.\n  const stride = 4 * Float32Array.BYTES_PER_ELEMENT;\n  // Build a contiguous array of circle vertex data:\n  // Each circle contributes: x, y, radius, alpha.\n  const circleData = new Float32Array(circles.length * 4);\n  // Iterate over each circle in the queue and add its data to circleData.\n  circles.forEach((c, i) => {\n    const offset = i * 4;\n    // Set circle data: position, radius and normalized alpha.\n    circleData.set([c.x, c.y, c.radius, c.alpha], offset);\n  });\n  // Clear the circles array to avoid redrawing on subsequent calls.\n  circles = [];\n  // Create and bind a vertex array object (VAO) along with the associated buffer.\n  // The helper function 'createAndBindBuffer' sets up the attributes using the\n  // 'Attr' locations previously determined.\n  const { vao, buf } = createAndBindBuffer(\n    circleData,\n    [\n      { name: \"a_position\", size: 2, offset: 0 },\n      { name: \"a_radius\", size: 1, offset: 2 * Float32Array.BYTES_PER_ELEMENT },\n      { name: \"a_alpha\", size: 1, offset: 3 * Float32Array.BYTES_PER_ELEMENT },\n    ],\n    stride\n  );\n  // Set the uniform for the projection matrix (u_matrix).\n  gl.uniformMatrix4fv(Frag.u_matrix, false, matrix);\n  // Set the shape type flag:\n  // If drawing squares (isSquare true) the shader outputs a square, otherwise a circle.\n  gl.uniform1i(Frag.u_drawSquare, isSquare ? 1 : 0);\n  // Bind the VAO containing our prepared buffer data.\n  gl.bindVertexArray(vao);\n  // Draw the circles as points.\n  //   The number of points equals the number of circles (circleData.length / 4).\n  gl.drawArrays(gl.POINTS, 0, circleData.length / 4);\n  gl.bindVertexArray(null);\n  gl.deleteBuffer(buf);\n  gl.deleteVertexArray(vao);\n}\n\nlet circles = [];\nlet isSquare = false;\n\n// =============================================================================\n// Section: Public Drawing Methods\n// =============================================================================\n\n/**\n * Queues a circle to be drawn.\n * @param {number} x - x-coordinate.\n * @param {number} y - y-coordinate.\n * @param {number} diameter - Diameter of the circle.\n * @param {number} alpha - Opacity (0-100).\n */\nexport function circle(x, y, diameter, alpha) {\n  isReady();\n  const radius = diameter / 2;\n  circles.push({\n    x: x + Matrix.x,\n    y: y + Matrix.y,\n    radius,\n    alpha: alpha / 100,\n  });\n  isSquare = false;\n}\n\n/**\n * Queues a square (via point sprite) to be drawn.\n * @param {number} x - x-coordinate.\n * @param {number} y - y-coordinate.\n * @param {number} size - Side length of the square.\n * @param {number} alpha - Opacity (0-100).\n */\nexport function square(x, y, size, alpha) {\n  isReady();\n  const radius = size / 2 / 1.2;\n  circles.push({\n    x: x + Matrix.x,\n    y: y + Matrix.y,\n    radius,\n    alpha: alpha / 100,\n  });\n  isSquare = true;\n}\n","/**\n * Compiles a shader program from the given vertex and fragment sources.\n * @param {WebGL2RenderingContext} gl - The WebGL2 context.\n * @param {string} vert - Vertex shader source.\n * @param {string} frag - Fragment shader source.\n * @returns {WebGLProgram} The compiled and linked program.\n */\nexport const createProgram = (gl, vert, frag) => {\n    const p = gl.createProgram();\n    for (let [t, src] of [\n        [gl.VERTEX_SHADER, vert],\n        [gl.FRAGMENT_SHADER, frag],\n    ]) {\n        const s = gl.createShader(t);\n        gl.shaderSource(s, src);\n        gl.compileShader(s);\n        gl.attachShader(p, s);\n    }\n    gl.linkProgram(p);\n    return p;\n};","// =============================================================================\n// Module: Brush\n// =============================================================================\n/**\n * The Brush module provides a comprehensive set of functions and classes for\n * simulating various drawing tools ranging from pens, markers, pencils, to\n * custom image-based brushes. This module controls brush properties such as\n * weight, color, vibration, and spacing, and manages the drawing process through\n * stateful methods that enable features like pressure sensitivity, clipping, and\n * blending. By supporting multiple brush types and dynamic parameter adjustments,\n * the Brush module facilitates the creation of realistic and expressive stroke effects.\n */\n\nimport { Color, Mix, Cwidth, Cheight, State } from \"../core/color.js\";\nimport {\n  rr,\n  map,\n  dist,\n  randInt,\n  calcAngle,\n  toDegrees,\n  gaussian,\n  noise,\n  rArray\n} from \"../core/utils.js\";\nimport { Position, Matrix, isFieldReady } from \"../core/flowfield.js\";\nimport { Polygon } from \"../core/polygon.js\";\nimport { Plot } from \"../core/plot.js\";\nimport { isReady, glDraw, circle, square } from \"./gl_draw.js\";\n\nconst PI2 = Math.PI * 2;\n\n// ---------------------------------------------------------------------------\n// Brush State and Helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Global stroke state settings.\n */\nState.stroke = {\n  color: new Color(\"black\"),\n  weight: 1,\n  clipWindow: null,\n  type: \"HB\",\n  isActive: false,\n};\n\nlet list = new Map();\n\n/**\n * Retrieves a shallow copy of the current stroke state.\n * @returns {object} The stroke state.\n */\nexport function BrushState() {\n  return { ...State.stroke };\n}\n\n/**\n * Updates the stroke state.\n * @param {object} state - The new stroke state.\n */\nexport function BrushSetState(state) {\n  State.stroke = { ...state };\n}\n\n// =============================================================================\n// Section: Brush Manager\n// =============================================================================\n\n/**\n * Adds a new brush with the specified parameters to the brush list.\n * @param {string} name - The unique name for the new brush.\n * @param {object} params - The parameters defining the brush behavior and appearance.\n */\nexport function add(name, params) {\n  const validTypes = [\"marker\", \"custom\", \"image\", \"spray\"];\n  params.type = validTypes.includes(params.type) ? params.type : \"default\";\n  list.set(name, { param: params, colors: [], buffers: [] });\n}\n\n/**\n * Retrieves the list of available brush names.\n * @returns {Array<string>} Array of brush names.\n */\nexport function box() {\n  return [...list.keys()];\n}\n\n/**\n * Scales standard brush parameters by the provided factor.\n * @param {number} scaleFactor - The scaling factor to apply.\n */\nexport function scaleBrushes(scaleFactor) {\n  for (const { param } of list.values()) {\n    if (param) {\n      param.weight *= scaleFactor;\n      param.vibration *= scaleFactor;\n      param.spacing *= scaleFactor;\n    }\n  }\n}\n\n/**\n * Sets the current brush type by name.\n * @param {string} brushName - The name of the brush.\n */\nexport function pick(brushName) {\n  if (list.has(brushName)) State.stroke.type = brushName;\n}\n\n/**\n * Sets the stroke style (color) for the current brush.\n * @param {number|string|Color} r - Red component, CSS color string, or Color object.\n * @param {number} [g] - Green component.\n * @param {number} [b] - Blue component.\n */\nexport function strokeStyle(r, g, b) {\n  State.stroke.color = new Color(...arguments);\n  State.stroke.isActive = true;\n}\n\n/**\n * Sets the brush weight (thickness).\n * @param {number} weight - The weight value.\n */\nexport function lineWidth(weight) {\n  State.stroke.weight = weight;\n}\n\n/**\n * Sets the current brush with name, color, and weight.\n * @param {string} brushName - The brush name.\n * @param {string|Color} color - The brush color.\n * @param {number} [weight=1] - The brush weight.\n */\nexport function set(brushName, color, weight = 1) {\n  pick(brushName);\n  strokeStyle(color);\n  lineWidth(weight);\n}\n\n/**\n * Disables the stroke effect.\n */\nexport function noStroke() {\n  State.stroke.isActive = false;\n}\n\n/**\n * Defines a clipping region for strokes.\n * @param {number[]} region - Array as [x1, y1, x2, y2] defining the clipping region.\n */\nexport function clip(region) {\n  State.stroke.clipWindow = region;\n}\n\n/**\n * Disables the clipping region.\n */\nexport function noClip() {\n  State.stroke.clipWindow = null;\n}\n\n/**\n * Sets the brush density by scaling standard brushes.\n * @param {number} d - Density factor.\n */\nexport function setDensity(d) {\n  scaleBrushes(d);\n}\n\n// ---------------------------------------------------------------------------\n// Drawing Variables and Functions\n// ---------------------------------------------------------------------------\nlet _position, _length, _flow, _plot, _dir, _alpha;\nconst current = {};\n\n/**\n * Initializes the drawing state.\n * @param {number} x - Starting x-coordinate.\n * @param {number} y - Starting y-coordinate.\n * @param {number} length - Length of stroke.\n * @param {boolean} flow - Flag for vector-field following.\n * @param {Object|boolean} plot - Plot object or false.\n */\nfunction initializeDrawingState(x, y, length, flow, plot) {\n  _position = new Position(x, y);\n  _length = length;\n  _flow = flow;\n  _plot = plot;\n  if (_plot) _plot.calcIndex(0);\n}\n\nconst gaussians = [];\n\n/**\n * Executes the drawing operation.\n * @param {number} angleScale - Angle (in degrees) or scaling factor.\n * @param {boolean} isPlot - True if plotting a shape.\n */\nfunction draw(angleScale, isPlot) {\n  if (!isPlot) _dir = angleScale;\n  saveState();\n\n  const stepSize = spacing();\n  const totalSteps = Math.round(\n    (_length * (isPlot ? angleScale : 1)) / stepSize\n  );\n  for (let i = 0; i < totalSteps; i++) {\n    if (gaussians.length < totalSteps * 2) { gaussians.push(gaussian()); }\n    tip();\n    isPlot\n      ? _position.plotTo(\n          _plot,\n          stepSize,\n          stepSize,\n          angleScale,\n          i < 10 ? true : false\n        )\n      : _position.moveTo(stepSize, angleScale, stepSize, _flow);\n  }\n  restoreState();\n}\n\n/**\n * Prepares the environment for a brush stroke.\n */\nfunction saveState() {\n  current.seed = rr() * 99999;\n  const { param } = list.get(State.stroke.type) ?? {};\n  if (!param) return;\n  current.p = param;\n\n  // Set pressure values for the stroke\n  const { pressure } = param;\n  current.a = pressure.type !== \"custom\" ? rr(-1, 1) : 0;\n  current.b = pressure.type !== \"custom\" ? rr(1, 1.5) : 0;\n  current.cp = pressure.type !== \"custom\" ? rr(3, 3.5) : rr(-0.2, 0.2);\n  [current.min, current.max] = pressure.min_max;\n\n  // Ensure GL is ready and blend state\n  isReady();\n  Mix.blend(State.stroke.color);\n  Mix.isBrush = true;\n\n  // Set additional state values\n  current.alpha = calculateAlpha(); // Calculate Alpha\n  markerTip();\n}\n\n/**\n * Restores drawing state after completing a stroke.\n */\nfunction restoreState() {\n  glDraw(State.stroke.color);\n  markerTip();\n}\n\n/**\n * Renders the brush tip based on current pressure and position.\n * @param {number} [customPressure=false] - Optional custom pressure.\n */\nfunction tip(customPressure = false) {\n  if (!isInsideClippingArea()) return;\n  let pressure = customPressure || calculatePressure();\n  pressure *=\n    1 -\n    0.2 *\n      noise(_position.plotted * 0.01 + current.seed, 1) -\n    0.2 * noise(_position.x * 0.003, _position.y * 0.003);\n\n  switch (current.p.type) {\n    case \"spray\":\n      drawSpray(pressure);\n      break;\n    case \"marker\":\n      drawMarker(pressure);\n      break;\n    case \"custom\":\n    case \"image\":\n      drawCustomOrImage(pressure, _alpha);\n      break;\n    default:\n      drawDefault(pressure);\n      break;\n  }\n}\n\n/**\n * Calculates the effective brush pressure.\n * @returns {number} The calculated pressure.\n */\nfunction calculatePressure() {\n  return _plot\n    ? simPressure() * _plot.pressure(_position.plotted)\n    : simPressure();\n}\n\n/**\n * Simulates brush pressure based on stroke parameters.\n * @returns {number} Simulated pressure value.\n */\nfunction simPressure() {\n  return current.p.pressure.type === \"custom\"\n    ? map(\n        current.p.pressure.curve(_position.plotted / _length) + current.cp,\n        0,\n        1,\n        current.min,\n        current.max,\n        true\n      )\n    : gauss();\n}\n\n/**\n * Generates a Gaussian-based pressure value.\n * @param {number} [a] - Center parameter.\n * @param {number} [b] - Width parameter.\n * @param {number} [c] - Shape parameter.\n * @param {number} [min] - Minimum pressure.\n * @param {number} [max] - Maximum pressure.\n * @returns {number} Gaussian pressure value.\n */\nfunction gauss(\n  a = 0.5 + current.p.pressure.curve[0] * current.a,\n  b = 1 - current.p.pressure.curve[1] * current.b,\n  c = current.cp,\n  min = current.min,\n  max = current.max\n) {\n  return map(\n    1 /\n      (1 +\n        Math.pow(\n          Math.abs((_position.plotted - a * _length) / ((b * _length) / 2)),\n          2 * c\n        )),\n    0,\n    1,\n    min,\n    max\n  );\n}\n\n/**\n * Calculates the alpha (opacity) level for a brush stroke.\n * @returns {number} The calculated opacity.\n */\nfunction calculateAlpha() {\n  return [\"default\", \"spray\"].includes(current.p.type)\n    ? current.p.opacity\n    : current.p.opacity / State.stroke.weight;\n}\n\n/**\n * Checks if the current drawing position is within the clipping region.\n * @returns {boolean} True if inside clipping area; false otherwise.\n */\nfunction isInsideClippingArea() {\n  if (State.stroke.clipWindow)\n    return (\n      _position.x >= State.stroke.clipWindow[0] &&\n      _position.x <= State.stroke.clipWindow[2] &&\n      _position.y >= State.stroke.clipWindow[1] &&\n      _position.y <= State.stroke.clipWindow[3]\n    );\n  else {\n    let w = Cwidth,\n      h = Cheight,\n      o = Cwidth * 0.05;\n    let x = _position.x + Matrix.x;\n    let y = _position.y + Matrix.y;\n    return x >= -o && x <= w + o && y >= -o && y <= h + o;\n  }\n}\n\n/**\n * Calculates the step spacing based on the current brush parameters.\n * @returns {number} The spacing value.\n */\nfunction spacing() {\n  const { param } = list.get(State.stroke.type) ?? {};\n  if (!param) return 1;\n  return param.type === \"default\" || param.type === \"spray\"\n    ? param.spacing / State.stroke.weight\n    : param.spacing;\n}\n\n// ---------------------------------------------------------------------------\n// Brush Tip Rendering Methods\n// ---------------------------------------------------------------------------\n\n/**\n * Draws the spray tip effect.\n * @param {number} pressure - Current pressure.\n */\nfunction drawSpray(pressure) {\n  const vibration =\n    State.stroke.weight * current.p.vibration * pressure +\n    (State.stroke.weight * rArray(gaussians) * current.p.vibration) / 3;\n  const sw = State.stroke.weight * rr(0.9, 1.1);\n  const iterations = Math.ceil(current.p.quality / pressure);\n  for (let j = 0; j < iterations; j++) {\n    const r = rr(0.9, 1.1);\n    const rX = r * vibration * rr(-1, 1);\n    const yRandomFactor = rr(-1, 1);\n    const sqrtPart = Math.sqrt((r * vibration) ** 2 - rX ** 2);\n    square(\n      _position.x + rX,\n      _position.y + yRandomFactor * sqrtPart,\n      sw,\n      current.alpha\n    );\n  }\n}\n\n/**\n * Draws the marker tip effect.\n * @param {number} pressure - Current pressure.\n * @param {boolean} [vibrate=true] - Whether to apply vibration.\n */\nfunction drawMarker(pressure, vibrate = true, alpha = current.alpha) {\n  const vibration = vibrate ? State.stroke.weight * current.p.vibration : 0;\n  const rx = vibrate ? vibration * rr(-1, 1) : 0;\n  const ry = vibrate ? vibration * rr(-1, 1) : 0;\n  circle(\n    _position.x + rx,\n    _position.y + ry,\n    State.stroke.weight * current.p.weight * pressure,\n    alpha\n  );\n}\n\n/**\n * Draws a custom or image-based brush tip.\n * @param {number} pressure - Current pressure.\n * @param {number} alpha - Alpha (opacity) for drawing.\n * @param {boolean} [vibrate=true] - Whether to apply vibration.\n */\nfunction drawCustomOrImage(pressure, alpha, vibrate = true) {\n  Mix.ctx.save();\n  const vibration = vibrate ? State.stroke.weight * current.p.vibration : 0;\n  const rx = vibrate ? vibration * rr(-1, 1) : 0;\n  const ry = vibrate ? vibration * rr(-1, 1) : 0;\n  Mix.ctx.translate(_position.x + rx, _position.y + ry);\n  adjustSizeAndRotation(State.stroke.weight * pressure, alpha);\n  current.p.tip(Mix.ctx);\n  Mix.ctx.restore();\n}\n\n/**\n * Draws the default brush tip.\n * @param {number} pressure - Current pressure.\n */\nfunction drawDefault(pressure) {\n  const vibration =\n    State.stroke.weight *\n    current.p.vibration *\n    (current.p.definition +\n      ((1 - current.p.definition) * rArray(gaussians) * gauss(0.5, 0.9, 5, 0.2, 1.2)) /\n        pressure);\n  if (rr(0, current.p.quality * pressure) > 0.4) {\n    square(\n      _position.x + 0.7 * vibration * rr(-1, 1),\n      _position.y + vibration * rr(-1, 1),\n      pressure * current.p.weight * rr(0.85, 1.15),\n      current.alpha\n    );\n  }\n}\n\n/**\n * Adjusts the size and rotation of the brush tip before rendering.\n * @param {number} pressure - Pressure-based scaling factor.\n * @param {number} alpha - Opacity value.\n */\nfunction adjustSizeAndRotation(pressure, alpha) {\n  Mix.ctx.scale(pressure, pressure);\n  let angle = 0;\n  if (current.p.rotate === \"random\") angle = randInt(0, PI2);\n  else if (current.p.rotate === \"natural\") {\n    angle =\n      (_plot ? -_plot.angle(_position.plotted) : -_dir) +\n      (_flow ? _position.angle() : 0);\n    angle = (angle * Math.PI) / 180;\n  }\n  Mix.ctx.rotate(angle);\n}\n\n/**\n * Draws the marker tip with a blend effect.\n */\nfunction markerTip() {\n  if (isInsideClippingArea()) {\n    let pressure = calculatePressure();\n    let alpha = calculateAlpha(pressure);\n    if (current.p.type === \"marker\") {\n      for (let s = 1; s < 10; s++) {\n        drawMarker((pressure * s) / 10, false, alpha * 5);\n      }\n      glDraw(State.stroke.color);\n    } else if (current.p.type === \"custom\" || current.p.type === \"image\") {\n      for (let s = 1; s < 5; s++) {\n        Mix.ctx.beginPath();\n        current.drawCustomOrImage((pressure * s) / 5, alpha, false);\n        Mix.ctx.fill();\n      }\n    }\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Basic Drawing Operations\n// ---------------------------------------------------------------------------\n\n/**\n * Draws a line using the current brush.\n * @param {number} x1 - Start x-coordinate.\n * @param {number} y1 - Start y-coordinate.\n * @param {number} x2 - End x-coordinate.\n * @param {number} y2 - End y-coordinate.\n */\nexport function line(x1, y1, x2, y2) {\n  isFieldReady();\n  let d = dist(x1, y1, x2, y2);\n  if (d == 0) return;\n  initializeDrawingState(x1, y1, d, true, false);\n  let angle = calcAngle(x1, y1, x2, y2);\n  draw(angle, false);\n}\n\n/**\n * Draws a stroke from a starting point in a given direction.\n * @param {number} x - Starting x-coordinate.\n * @param {number} y - Starting y-coordinate.\n * @param {number} length - Length of the stroke.\n * @param {number} dir - Direction (in radians, anticlockwise from the x-axis).\n */\nexport function stroke(x, y, length, dir) {\n  isFieldReady();\n  initializeDrawingState(x, y, length, true, false);\n  draw(toDegrees(dir), false);\n}\n\n/**\n * Draws a predefined plot.\n * @param {object} p - Shape object representing the plot.\n * @param {number} x - Starting x-coordinate.\n * @param {number} y - Starting y-coordinate.\n * @param {number} scale - Scale factor.\n */\nfunction plot(p, x, y, scale) {\n  isFieldReady();\n  initializeDrawingState(x, y, p.length, true, p);\n  draw(scale, true);\n}\n\n// ---------------------------------------------------------------------------\n// Standard Brushes Definition and Initialization\n// ---------------------------------------------------------------------------\n\n/**\n * Defines a set of standard brushes with specific characteristics. Each brush is defined\n * with properties such as weight, vibration, definition, quality, opacity, spacing, and\n * pressure sensitivity. Some brushes have additional properties like type, tip, and rotate.\n */\nconst _vals = [\n  \"weight\",\n  \"vibration\",\n  \"definition\",\n  \"quality\",\n  \"opacity\",\n  \"spacing\",\n  \"pressure\",\n  \"type\",\n  \"tip\",\n  \"rotate\",\n];\nconst _standard_brushes = [\n  [\n    \"pen\",\n    [0.35, 0.12, 0.5, 8, 88, 0.3, { curve: [0.15, 0.2], min_max: [1.4, 0.9] }],\n  ],\n  [\n    \"rotring\",\n    [\n      0.2,\n      0.05,\n      0.5,\n      30,\n      115,\n      0.15,\n      { curve: [0.35, 0.2], min_max: [1.3, 0.9] },\n    ],\n  ],\n  [\n    \"2B\",\n    [0.35, 0.6, 0.1, 8, 140, 0.2, { curve: [0.15, 0.2], min_max: [1.5, 1] }],\n  ],\n  [\n    \"HB\",\n    [0.3, 0.5, 0.4, 4, 130, 0.25, { curve: [0.15, 0.2], min_max: [1.2, 0.9] }],\n  ],\n  [\n    \"2H\",\n    [0.2, 0.4, 0.3, 2, 60, 0.2, { curve: [0.15, 0.2], min_max: [1.2, 0.9] }],\n  ],\n  [\n    \"cpencil\",\n    [0.4, 0.55, 0.8, 7, 70, 0.15, { curve: [0.15, 0.2], min_max: [0.95, 1.2] }],\n  ],\n  [\n    \"charcoal\",\n    [\n      0.35,\n      1.5,\n      0.65,\n      300,\n      60,\n      0.06,\n      { curve: [0.15, 0.2], min_max: [1.3, 0.9] },\n    ],\n  ],\n  [\n    \"crayon\",\n    [0.25, 2, 0.8, 300, 60, 0.06, { curve: [0.35, 0.2], min_max: [0.9, 1.1] }],\n  ],\n  [\n    \"spray\",\n    [0.2, 12, 15, 40, 35, 0.65, { curve: [0, 0.1], min_max: [1, 1] }, \"spray\"],\n  ],\n  [\n    \"marker\",\n    [\n      2.5,\n      0.12,\n      null,\n      null,\n      0.4,\n      0.04,\n      { curve: [0.35, 0.25], min_max: [1.5, 1] },\n      \"marker\",\n    ],\n  ],\n];\n\nfor (let s of _standard_brushes) {\n  let obj = {};\n  for (let i = 0; i < s[1].length; i++) obj[_vals[i]] = s[1][i];\n  add(s[0], obj);\n}\n\n// ---------------------------------------------------------------------------\n// Extensions to Polygon and Plot Prototypes\n// ---------------------------------------------------------------------------\n\n/**\n * Draws the polygon using the current brush.\n * @param {boolean} [_brush=false] - Optional brush name override.\n * @param {string|Color} [_color] - Optional color override.\n * @param {number} [_weight] - Optional weight override.\n */\nPolygon.prototype.draw = function (_brush = false, _color, _weight) {\n  let state = BrushState();\n  if (_brush) set(_brush, _color, _weight);\n  if (state.isActive) {\n    for (let s of this.sides) {\n      line(s[0].x, s[0].y, s[1].x, s[1].y);\n    }\n  }\n  BrushSetState(state);\n};\n\n/**\n * Draws the plot using the current brush.\n * @param {number} x - Starting x-coordinate.\n * @param {number} y - Starting y-coordinate.\n * @param {number} scale - Scale factor.\n */\nPlot.prototype.draw = function (x, y, scale) {\n  if (BrushState().isActive) {\n    if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n    plot(this, x, y, scale);\n  }\n};\n","// =============================================================================\n// Module: Hatch\n// =============================================================================\n/**\n * The Hatch module contains functions and classes dedicated to applying\n * hatch patterns over shapes and polygons. It enables the simulation of\n * cross-hatching and shading effects by drawing parallel lines or strokes\n * across a geometry. The module supports adjustable spacing, angle, and\n * optional style parameters (such as randomness, continuity, and gradient),\n * giving an artistic representation similar to hand-drawn hatching techniques.\n *\n * The implementation allows for hatching to be applied either to a Polygon\n * directly or via a Plot, extending the drawing capabilities with layered,\n * stylized textures.\n */\n\nimport { State } from \"../core/color.js\";\nimport { toDegrees, map, cos, sin, rr } from \"../core/utils.js\";\nimport { Polygon } from \"../core/polygon.js\";\nimport { Plot } from \"../core/plot.js\";\nimport { BrushState, BrushSetState, set, line } from \"../stroke/stroke.js\";\n\n// ---------------------------------------------------------------------------\n// Hatch State and Helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Global hatch state settings.\n */\nState.hatch = {\n  isActive: false,\n  dist: 5,\n  angle: 45,\n  options: {},\n  hBrush: false,\n};\n\n/**\n * Returns a shallow copy of the current hatch state.\n * @returns {object} The current hatch state.\n */\nfunction HatchState() {\n  return { ...State.hatch };\n}\n\n/**\n * Updates the global hatch state.\n * @param {object} state - The new hatch state.\n */\nfunction HatchSetState(state) {\n  State.hatch = { ...state };\n}\n\n// ---------------------------------------------------------------------------\n// Hatch Style Functions\n// ---------------------------------------------------------------------------\n\n/**\n * Activates hatching for subsequent geometries.\n *\n * @param {number} dist - The distance between hatching lines.\n * @param {number} angle - The angle (in degrees) at which hatching lines are drawn.\n * @param {object} options - Optional parameters to affect the hatching style:\n *                           - rand: Number value to introduce randomness.\n *                           - continuous: Boolean to connect adjacent lines.\n *                           - gradient: Number to gradually change spacing.\n */\nexport function hatch(\n  dist = 5,\n  angle = 45,\n  options = { rand: false, continuous: false, gradient: false }\n) {\n  let s = State.hatch;\n  s.isActive = true;\n  s.dist = dist;\n  s.angle = angle;\n  s.options = options;\n}\n\n/**\n * Sets the hatch brush style for subsequent hatching.\n *\n * @param {string} brush - The brush name.\n * @param {string|Color} color - The brush color.\n * @param {number} weight - The brush weight (size).\n */\nexport function hatchStyle(brush, color = \"black\", weight = 1) {\n  State.hatch.hBrush = { brush, color, weight };\n}\n\n/**\n * Disables hatching.\n */\nexport function noHatch() {\n  State.hatch.isActive = false;\n  State.hatch.hBrush = false;\n}\n\n// ---------------------------------------------------------------------------\n// Fill Manager Functions\n// ---------------------------------------------------------------------------\n\n/**\n * Creates a hatching pattern over the given polygon(s).\n *\n * @param {Polygon|Polygon[]} polygons - A polygon or an array of polygons.\n */\nexport function createHatch(polygons) {\n  let dist = State.hatch.dist;\n  let angle = toDegrees(State.hatch.angle) % 180; // normalize to [0, 180)\n  let options = State.hatch.options;\n\n  // Save current stroke state\n  let save = BrushState();\n  // If a hatch brush is set, override with those parameters.\n  if (State.hatch.hBrush) set(...Object.values(State.hatch.hBrush));\n\n  // Compute overall bounding box for all polygons.\n  if (!Array.isArray(polygons)) polygons = [polygons];\n  const overallBB = computeOverallBoundingBox(polygons);\n\n  // Build a bounding polygon based on the overall bounding box.\n  let ventana = new Polygon([\n    [overallBB.minX, overallBB.minY],\n    [overallBB.maxX, overallBB.minY],\n    [overallBB.maxX, overallBB.maxY],\n    [overallBB.minX, overallBB.maxY],\n  ]);\n\n  // Determine starting y coordinate based on angle.\n  let startY = angle <= 90 && angle >= 0 ? overallBB.minY : overallBB.maxY;\n  let gradient = options.gradient\n    ? map(options.gradient, 0, 1, 1, 1.1, true)\n    : 1;\n  let dots = [];\n  let i = 0;\n  let dist1 = dist;\n\n  // Function to generate a hatched line for index i.\n  let linea = (i) => {\n    return {\n      point1: {\n        x: overallBB.minX + dist1 * i * cos(-angle + 90),\n        y: startY + dist1 * i * sin(-angle + 90),\n      },\n      point2: {\n        x: overallBB.minX + dist1 * i * cos(-angle + 90) + cos(-angle),\n        y: startY + dist1 * i * sin(-angle + 90) + sin(-angle),\n      },\n    };\n  };\n\n  // Generate lines and calculate intersections with polygons\n  // Loop through the lines based on the distance and angle to calculate intersections with the polygons\n  // The loop continues until a line does not intersect with the bounding window polygon\n  // Each iteration accounts for the gradient effect by adjusting the distance between lines\n  while (ventana.intersect(linea(i)).length > 0) {\n    let tempArray = [];\n    for (let p of polygons) {\n      tempArray.push(p.intersect(linea(i)));\n    }\n    dots[i] = tempArray\n      .flat()\n      .sort((a, b) => (a.x === b.x ? a.y - b.y : a.x - b.x));\n    dist1 *= gradient;\n    i++;\n  }\n\n  // Filter out empty intersection sets.\n  let gdots = dots.filter((dd) => typeof dd[0] !== \"undefined\");\n\n  // Draw the hatching lines using the calculated intersections\n  // If the 'rand' option is enabled, add randomness to the start and end points of the lines\n  // If the 'continuous' option is set, connect the end of one line to the start of the next\n  let r = options.rand || 0;\n  for (let j = 0; j < gdots.length; j++) {\n    let dd = gdots[j];\n    let continuousLine = j > 0 && options.continuous;\n    for (let i = 0; i < dd.length - 1; i += 2) {\n      if (r !== 0) {\n        dd[i].x += r * dist * rr(-10, 10);\n        dd[i].y += r * dist * rr(-10, 10);\n        dd[i + 1].x += r * dist * rr(-10, 10);\n        dd[i + 1].y += r * dist * rr(-10, 10);\n      }\n      line(dd[i].x, dd[i].y, dd[i + 1].x, dd[i + 1].y);\n      if (continuousLine) {\n        line(gdots[j - 1][1].x, gdots[j - 1][1].y, dd[i].x, dd[i].y);\n      }\n    }\n  }\n\n  // Restore previous brush state.\n  BrushSetState(save);\n}\n\n/**\n * Computes the bounding box for a single polygon.\n * @param {Polygon} polygon - The polygon to evaluate.\n * @returns {object} The bounding box as {minX, minY, maxX, maxY}.\n */\nfunction computeBoundingBoxForPolygon(polygon) {\n  if (polygon._boundingBox) return polygon._boundingBox;\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  for (let i = 0; i < polygon.a.length; i++) {\n    const [x, y] = polygon.a[i];\n    if (x < minX) minX = x;\n    if (x > maxX) maxX = x;\n    if (y < minY) minY = y;\n    if (y > maxY) maxY = y;\n  }\n  polygon._boundingBox = { minX, minY, maxX, maxY };\n  return polygon._boundingBox;\n}\n\n/**\n * Computes an overall bounding box for an array of polygons.\n * @param {Array} polygons - Array of Polygon objects.\n * @returns {object} The overall bounding box {minX, minY, maxX, maxY}.\n */\nfunction computeOverallBoundingBox(polygons) {\n  let overall = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n  };\n  for (let poly of polygons) {\n    const bb = computeBoundingBoxForPolygon(poly);\n    overall.minX = Math.min(overall.minX, bb.minX);\n    overall.minY = Math.min(overall.minY, bb.minY);\n    overall.maxX = Math.max(overall.maxX, bb.maxX);\n    overall.maxY = Math.max(overall.maxY, bb.maxY);\n  }\n  return overall;\n}\n\n// ---------------------------------------------------------------------------\n// Extend Polygon and Plot Prototypes\n// ---------------------------------------------------------------------------\n\n/**\n * Adds a hatch effect to the polygon.\n *\n * If a distance is provided, activates hatching with the given parameters.\n * Then, if hatch is active, applies the hatching pattern.\n *\n * @param {number} [_dist] - The distance between hatch lines.\n * @param {number} _angle - The angle (in degrees) for hatching.\n * @param {object} _options - Optional hatch options.\n */\nPolygon.prototype.hatch = function (_dist = false, _angle, _options) {\n  let state = HatchState();\n  if (_dist) hatch(_dist, _angle, _options);\n  if (state.isActive) {\n    createHatch(this);\n  }\n  HatchSetState(state);\n};\n\n/**\n * Applies hatching to a plot.\n *\n * If hatching is active, generates a polygon from the plot and applies hatch.\n *\n * @param {number} x - The x-coordinate to draw at.\n * @param {number} y - The y-coordinate to draw at.\n * @param {number} scale - Scaling factor.\n */\nPlot.prototype.hatch = function (x, y, scale) {\n  if (HatchState().isActive) {\n    if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n    this.pol = this.genPol(x, y, scale, 0.25);\n    this.pol.hatch();\n  }\n};\n","// =============================================================================\n// Module: Fill\n// =============================================================================\n/**\n * The Fill module contains functions and classes dedicated to handling\n * the fill properties of shapes within the drawing context. It supports complex fill\n * operations with effects such as bleeding to simulate watercolor-like textures. The\n * methods provided allow for setting the fill color with opacity, controlling the\n * intensity of the bleed effect, and enabling or disabling the fill operation.\n *\n * The watercolor effect implementation is inspired by Tyler Hobbs'\n * techniques for simulating watercolor paints.\n */\n\nimport { Color, Mix, State } from \"../core/color.js\";\nimport { drawPolygon, circle } from \"../core/mask.js\";\nimport {\n  constrain,\n  weightedRand,\n  rr,\n  map,\n  randInt,\n  gaussian,\n  rArray,\n  rotate,\n} from \"../core/utils.js\";\nimport { BleedField, isFieldReady } from \"../core/flowfield.js\";\nimport { Polygon } from \"../core/polygon.js\";\nimport { Plot } from \"../core/plot.js\";\n\n// =============================================================================\n// Fill State and helpers\n// =============================================================================\n\n/**\n * Global fill state settings.\n */\nState.fill = {\n  color: new Color(\"#002185\"),\n  opacity: 60,\n  bleed_strength: 0.07,\n  texture_strength: 0.8,\n  border_strength: 0.5,\n  direction: \"out\",\n  isActive: false,\n};\n\n/**\n * Returns a shallow copy of the current fill state.\n * @returns {Object} The current fill state.\n */\nfunction FillState() {\n  return { ...State.fill };\n}\n\n/**\n * Updates the global fill state.\n * @param {Object} state - The new fill state.\n */\nfunction FillSetState(state) {\n  State.fill = { ...state };\n}\n\n// ---------------------------------------------------------------------------\n// Fill Style Functions\n// ---------------------------------------------------------------------------\n\n/**\n * Sets the fill color and opacity for subsequent drawing operations.\n * @param {number|string|Color} a - Either the red component, a CSS color string, or a Color object.\n * @param {number} [b] - The green component or the opacity if using grayscale.\n * @param {number} [c] - The blue component.\n * @param {number} [d] - The opacity.\n */\nexport function fillStyle(a, b, c, d) {\n  State.fill.opacity = (arguments.length < 4 ? b : d) || 60;\n  State.fill.color = arguments.length < 3 ? new Color(a) : new Color(a, b, c);\n  State.fill.isActive = true;\n}\n\n/**\n * Sets the bleed (watercolor) intensity and direction.\n * @param {number} _i - The bleed intensity (clamped to [0,1]).\n * @param {string} [_direction=\"out\"] - The bleeding direction.\n */\nexport function fillBleed(_i, _direction = \"out\") {\n  State.fill.bleed_strength = constrain(_i, 0, 1);\n  State.fill.direction = _direction;\n}\n\n/**\n * Sets the texture and border strengths for the fill.\n * @param {number} [_texture=0.4] - The texture strength (clamped to [0,1]).\n * @param {number} [_border=0.4] - The border strength (clamped to [0,1]).\n */\nexport function fillTexture(_texture = 0.4, _border = 0.4) {\n  State.fill.texture_strength = constrain(_texture, 0, 1);\n  State.fill.border_strength = constrain(_border, 0, 1);\n}\n\n/**\n * Disables fill for subsequent drawing operations.\n */\nexport function noFill() {\n  State.fill.isActive = false;\n}\n\n// ---------------------------------------------------------------------------\n// Fill Manager Functions\n// ---------------------------------------------------------------------------\n\nlet fillPolygon;\n\n/**\n * Fills a given polygon with a watercolor effect.\n * @param {Polygon} polygon - The polygon to fill.\n */\nexport function createFill(polygon) {\n  // Store polygon\n  fillPolygon = polygon;\n  // Map polygon vertices to Vector objects\n  let v = [...polygon.vertices];\n  const vLength = v.length;\n  // Calculate fluidity once, outside the loop\n  const fluid = vLength * 0.25 * weightedRand({ 1: 5, 2: 10, 3: 60 });\n  // Map vertices to bleed multipliers with more intense effect on 'fluid' vertices\n  const strength = State.fill.bleed_strength;\n  let modifiers = v.map((_, i) => {\n    let multiplier = rr(0.85, 1.2) * strength;\n    return i > fluid ? multiplier : multiplier * 0.2;\n  });\n  // Shift vertices randomly for natural edges.\n  const shift = randInt(0, vLength);\n  v = [...v.slice(shift), ...v.slice(0, shift)];\n  const center = calcCenter(v);\n  // Create and fill the polygon with the calculated bleed effect\n  let pol = new FillPolygon(v, modifiers, center, [], true);\n  pol.fill(\n    State.fill.color,\n    map(State.fill.opacity, 0, 100, 0, 1, true),\n    State.fill.texture_strength\n  );\n}\n\n/**\n * Calculates the centroid of a polygon from its vertices.\n * @param {Object[]} pts - Array of points with {x, y}.\n * @returns {Object} The center point {x, y}.\n */\nfunction calcCenter(pts) {\n  pts = [...pts];\n  const first = pts[0],\n    last = pts[pts.length - 1];\n  if (first.x !== last.x || first.y !== last.y) pts.push(first);\n  let twicearea = 0,\n    x = 0,\n    y = 0,\n    nPts = pts.length;\n  for (let i = 0, j = nPts - 1; i < nPts; j = i++) {\n    const p1 = pts[i],\n      p2 = pts[j];\n    const f =\n      (p1.y - first.y) * (p2.x - first.x) - (p2.y - first.y) * (p1.x - first.x);\n    twicearea += f;\n    x += (p1.x + p2.x - 2 * first.x) * f;\n    y += (p1.y + p2.y - 2 * first.y) * f;\n  }\n  const f = twicearea * 3;\n  return { x: x / f + first.x, y: y / f + first.y };\n}\n\n// ---------------------------------------------------------------------------\n// FillPolygon Class\n// ---------------------------------------------------------------------------\n\nconst gaussiansA = []\nconst gaussiansB = []\n\n/**\n * The FillPolygon class is used to create and manage the properties of the polygons that produces\n * the watercolor effect. It includes methods to grow (expand) the polygon and apply layers\n * of color with varying intensity and erase parts to simulate a natural watercolor bleed.\n * The implementation follows Tyler Hobbs' guide to simulating watercolor:\n * https://tylerxhobbs.com/essays/2017/a-generative-approach-to-simulating-watercolor-paints\n */\nclass FillPolygon {\n  /**\n   * Constructs a FillPolygon.\n   * @param {Object[]} _v - Vertices of the polygon.\n   * @param {number[]} _m - Multipliers for the bleed effect at each vertex.\n   * @param {Object} _center - The polygon's center {x, y}.\n   * @param {boolean[]} dir - Array indicating bleed direction per vertex.\n   * @param {boolean} isFirst - True for initial polygon.\n   */\n  constructor(_v, _m, _center, dir, isFirst, sizeX, sizeY) {\n    this.v = _v;\n    this.dir = dir;\n    this.m = _m;\n    this.sizeX = sizeX;\n    this.sizeY = sizeY;\n    this.midP = _center; \n    // Calculate bleed direction for the initial shape.\n    if (isFirst) {\n      this.sizeX = -Infinity;\n      this.sizeY = -Infinity;\n      for (let v of this.v) {\n        this.sizeX = Math.max(Math.abs(this.midP.x - v.x), this.sizeX);\n        this.sizeY = Math.max(Math.abs(this.midP.y - v.y), this.sizeY);\n      }\n      for (let i = 0; i < this.v.length; i++) {\n        const v1 = this.v[i];\n        const v2 = this.v[(i + 1) % this.v.length];\n        const side = { x: v2.x - v1.x, y: v2.y - v1.y };\n        const rt = rotate(0, 0, side.x, side.y, 90);\n        let linea = {\n          point1: { x: v1.x + side.x / 2, y: v1.y + side.y / 2 },\n          point2: { x: v1.x + side.x / 2 + rt.x, y: v1.y + side.y / 2 + rt.y },\n        };\n        const isLeft = (a, b, c) => {\n          return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) > 0.01;\n        };\n        let d1 = 0;\n        for (let int of fillPolygon.intersect(linea)) {\n          if (isLeft(v1, v2, int)) d1++;\n        }\n        this.dir[i] = d1 % 2 === 0 ? true : false;\n      }\n      this.midP = {x:_center.x + this.sizeX * rr(-0.3,0.3), y:_center.y + this.sizeY * rr(-0.3,0.3)};\n    }\n  }\n\n  /**\n   * Trims vertices from the polygon based on a factor.\n   * @param {number} [factor=1] - Factor determining amount of trimming.\n   * @returns {Object} An object containing trimmed vertices, multipliers, and direction.\n   */\n  trim(factor = 1) {\n    let v = [...this.v],\n      m = [...this.m],\n      dir = [...this.dir];\n    if (this.v.length > 8 && factor >= 0 && factor !== 1) {\n      const numTrim = ~~((1 - factor) * this.v.length);\n      const sp = ~~(this.v.length / 2 - numTrim / 2);\n      v.splice(sp, numTrim);\n      m.splice(sp, numTrim);\n      dir.splice(sp, numTrim);\n    }\n    return { v, m, dir };\n  }\n\n  /**\n   * Grows (or shrinks) the polygon vertices to simulate watercolor spread.\n   * @param {number} [growthFactor=1] - Factor controlling growth.\n   * @returns {FillPolygon} A new FillPolygon with adjusted vertices.\n   */\n  grow(growthFactor = 1) {\n    const { v: tr_v, m: tr_m, dir: tr_dir } = this.trim(growthFactor);\n    const len = tr_v.length;\n    const outLen = len * 2;\n    const newVerts = new Array(outLen);\n    const newMods  = new Array(outLen);\n    const newDirs  = new Array(outLen);\n\n    const bleedDirDeg = State.fill.direction === \"out\" ? -90 : 90;\n    // handle special growth cases inline\n\n    let idx = 0;\n\n    let mod = growthFactor === 999 ? rr(0.2, 0.6) : State.fill.bleed_strength / 1.7;\n    \n    for (let i = 0; i < len; i++) {\n      // compute two gaussians if necessary\n      if (gaussiansA.length < len * 1.5) {\n        gaussiansA.push(gaussian(0.5, 0.2));\n        gaussiansB.push(gaussian(0, 0.02));\n      }\n\n      const cv = tr_v[i];\n      // next vertex (wrap at end)\n      const nv = (i + 1 < len ? tr_v[i + 1] : tr_v[0]);\n\n      // compute modifier\n      if (growthFactor < 997) mod = BleedField.get(cv.x, cv.y, tr_m[i]);\n\n      // rotation in degrees, using utils.rotate\n      const rotDeg =\n        (tr_dir[i] ? bleedDirDeg : -bleedDirDeg) + rr(-1, 1) * 5;\n      const sideX = nv.x - cv.x, sideY = nv.y - cv.y;\n      const { x: dirX, y: dirY } = rotate(0, 0, sideX, sideY, rotDeg);\n      \n      // pick a random point along the edge\n      const t = rr(0.35, 0.65);\n      // compute outward distance\n      const d = rArray(gaussiansA) * rr(0.65, 1.35) * mod;\n\n      // first vertex: stay at cv\n      newVerts[idx] = cv;\n      newMods[idx]  = tr_m[i];\n      newDirs[idx++] = tr_dir[i];\n\n      // second vertex: offset by lerp + outward push\n      newVerts[idx] = {\n        x: cv.x + sideX * t + dirX * d,\n        y: cv.y + sideY * t + dirY * d,\n      };\n      newMods[idx]  = tr_m[i] + rArray(gaussiansB);\n      newDirs[idx++] = tr_dir[i];\n    }\n    return new FillPolygon(newVerts, newMods, this.midP, newDirs, false, this.sizeX, this.sizeY);\n  }\n\n  /**\n   * Fills the polygon with multiple layers to simulate a watercolor effect.\n   * @param {Color|string} color - The fill color.\n   * @param {number} intensity - Opacity intensity (mapped from 0 to 1).\n   * @param {number} tex - Texture factor.\n   */\n  fill(color, intensity, tex) {\n    // Precalculate stuff\n    const numLayers = 24;\n    const texture = tex * 3;\n    const int = intensity * (1 + tex / 2);\n\n    // Perform initial setup only once\n    Mix.blend(color);\n    Mix.ctx.save();\n    Mix.ctx.fillStyle = \"rgb(255 0 0 / \" + 2 * int + \"%)\";\n    Mix.ctx.strokeStyle =\n      \"rgb(255 0 0 / \" + 0.01 * State.fill.border_strength + \")\";\n\n    const size = Math.max(this.sizeX, this.sizeY);\n\n    Mix.ctx.lineCap = \"round\";\n\n    const darker = rr(0.15,0.7);\n\n    // Set the different polygons for texture\n    let pol = this.grow(),\n      pols;\n    for (let i = 0; i < numLayers; i++) {\n      if (i % 4 === 0) {\n        pol = pol.grow();\n      }\n      pols = [\n        pol.grow(1 - 0.0125 * i),\n        pol.grow(0.7 - 0.0125 * i),\n        pol.grow(0.4 - 0.0125 * i),\n      ];\n\n      // Draw layers\n      for (let p of pols) p.grow(997).grow().layer(i, size);\n      pol.grow(darker).grow(999).layer(i, size);\n      if (i % 6 === 0 || i === numLayers - 1) {\n        if (texture !== 0) pol.erase(texture * 4, intensity);\n        Mix.blend(color, true, false, true);\n      }\n    }\n    BleedField.update();\n    Mix.ctx.restore();\n  }\n\n  /**\n   * Draws a layer of the fill polygon with stroke and fill.\n   * @param {number} i - The layer index.\n   */\n  layer(i, size) {\n    Mix.ctx.lineWidth = map(i, 0, 24, size / 25, size / 30, true);\n    // Set fill and stroke properties once\n    drawPolygon(this.v);\n    Mix.ctx.fill();\n    Mix.ctx.stroke();\n  }\n\n  /**\n   * Erases parts of the polygon to create a natural watercolor texture.\n   * @param {number} texture - Texture strength factor.\n   * @param {number} intensity - Intensity value for size scaling.\n   */\n  erase(texture, intensity) {\n    Mix.ctx.save();\n    // Cache local values to avoid repeated property lookups\n    let numCircles = rr(60, 80) * map(texture, 0, 1, 2, 3.5);\n    const halfSizeX = this.sizeX / 1.7;\n    const halfSizeY = this.sizeY / 1.7;\n    const minSize =\n      Math.min(this.sizeX, this.sizeY) * (1.4 - State.fill.bleed_strength);\n    const minSizeFactor = 0.05 * minSize;\n    const maxSizeFactor = 0.4 * minSize;\n    const midX = this.midP.x;\n    const midY = this.midP.y;\n    Mix.ctx.globalCompositeOperation = \"destination-out\";\n    let i = (5 - map(intensity, 80, 100, 0.3, 1, true)) * texture;\n    Mix.ctx.fillStyle = \"rgb(255 0 0 / \" + i / 255 + \")\";\n    Mix.ctx.lineWidth = 0;\n    for (let i = 0; i < numCircles; i++) {\n      const x = midX + gaussian(0, halfSizeX);\n      const y = midY + gaussian(0, halfSizeY);\n      const size = rr(minSizeFactor, maxSizeFactor);\n      Mix.ctx.beginPath();\n      circle(x, y, size);\n      if (i % 4 !== 0) Mix.ctx.fill();\n    }\n    Mix.ctx.globalCompositeOperation = \"source-over\";\n    Mix.ctx.restore();\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Extend Polygon and Plot Prototypes for Fill\n// ---------------------------------------------------------------------------\n\n/**\n * Applies a fill effect to the polygon using the current fill state.\n * @param {Color|string} [_color] - The color for the fill.\n * @param {number} [_opacity] - The opacity value.\n * @param {number} [_bleed] - The bleed intensity.\n * @param {number} [_texture] - The texture strength.\n * @param {number} [_border] - The border strength.\n * @param {string} [_direction] - The bleed direction.\n */\nPolygon.prototype.fill = function (\n  _color = false,\n  _opacity,\n  _bleed,\n  _texture,\n  _border,\n  _direction\n) {\n  let state = FillState();\n  if (_color) {\n    fillStyle(_color, _opacity);\n    fillBleed(_bleed, _direction);\n    fillTexture(_texture, _border);\n  }\n  if (state.isActive) {\n    isFieldReady();\n    createFill(this);\n  }\n  FillSetState(state);\n};\n\n/**\n * Fills a plot on the canvas by generating a polygon based on the provided coordinates.\n * @param {number} x - The x-coordinate.\n * @param {number} y - The y-coordinate.\n * @param {number} scale - Scaling factor.\n */\nPlot.prototype.fill = function (x, y, scale) {\n  if (FillState().isActive) {\n    if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n    this.pol = this.genPol(x, y, scale, map(State.fill.bleed_strength,0,0.6,0.3,0.45,true));\n    this.pol.fill();\n  }\n};\n"],"names":["SQRT3","Math","sqrt","F2","G2","fastFloor","x","floor","grad2","Float64Array","createNoise2D","random","perm","p","Uint8Array","i","tableSize","r","aux","buildPermutationTable","permGrad2x","map","v","permGrad2y","y","n0","n1","n2","s","j","t","x0","y0","i1","j1","x1","y1","x2","y2","ii","jj","t0","gi0","t1","gi1","t2","gi2","prng_alea","seed","opts","xg","AleaGen","prng","next","double","int32","quick","constructor","Date","n","mash","data","String","length","charCodeAt","h","this","c","s0","s1","s2","copy","f","rng","exports","noise","rr","e","rArray","array","randInt","gaussian","mean","stdev","u","log","cos","weightedRand","weights","totalWeight","entries","key","push","cumulative","rnd","entry","isNaN","parseInt","value","a","b","d","withinBounds","constrain","low","high","max","min","nAngle","angle","totalDegrees","radiansPerIndex","PI","Float32Array","fill","NaN","idx","sin","toDegrees","rad","rotate","cx","cy","coseno","seno","dist","calcAngle","atan2","intersectLines","s1a","s1b","s2a","s2b","includeSegmentExtension","x3","y3","x4","y4","deltaX1","deltaY1","deltaX2","deltaY2","denominator","ua","ub","cloneArray","arr","slice","GL","canvas","gl","sh","createTexture","tex","bindTexture","TEXTURE_2D","texStorage2D","RGBA8","width","height","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","createFBO","texture","fb","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","fbo","isSafari","self","navigator","test","userAgent","blit","blitFramebuffer","COLOR_BUFFER_BIT","NEAREST","onmessage","async","event","getContext","antialias","mainProg","createProgram","src","VERTEX_SHADER","FRAGMENT_SHADER","createShader","shaderSource","compileShader","attachShader","linkProgram","useProgram","forEach","name","getUniformLocation","mask","source","target","activeTexture","TEXTURE0","TEXTURE1","uniform1i","u_source","u_mask","prepareGL","DRAW_FRAMEBUFFER","clearColor","clear","DEPTH_BUFFER_BIT","isBG","color","imageData","offctx","OffscreenCanvas","drawImage","getImageData","texSubImage2D","RGBA","UNSIGNED_BYTE","close","u_isImage","isImage","u_isBrush","isBrush","uniform4f","u_addColor","addColor","u_isErase","isErase","drawArrays","TRIANGLES","READ_FRAMEBUFFER","isLast","sp","applyShader","Worker","createURL","func_or_string","str","toString","blob","Blob","type","window","URL","createObjectURL","create","Canvases","cID","Cwidth","Cheight","_isReady","State","colorCanvas","document","createElement","colorCtx","Color","g","hex","standardize","rgb","hexToRgb","rgbToHex","replace","m","result","exec","fillStyle","isMixReady","Mix","loaded","Error","isCanvasReady","load","isBlending","currentColor","worker","ca","glMask","ctx","lineWidth","offscreen","transferControlToOffscreen","postMessage","Object","assign","blend","_color","_isLast","_isImg","_isFillLayer","newColor","transferToImageBitmap","Boolean","_bg_Color","Matrix","isLoaded","isFieldReady","resolution","left_x","top_y","num_columns","round","num_rows","addField","field","baseSize","baseAngle","timeFactor","column","columnNoise","row","noise_val","BleedField","genField","Position","update","plotted","column_index","getColIndex","row_index","getRowIndex","reset","isIn","isActive","isInCanvas","w","list","get","current","moveTo","_length","_dir","_step_length","isFlow","x_step","y_step","plotTo","_plot","_scale","inverse_scale","current_angle","plot_angle","y_offset","x_offset","col","Map","Array","funct","set","gen","fieldTemp","biggest","tempValue","save","A","B","restore","_saveState","drawPolygon","vertices","beginPath","lineTo","closePath","circle","PI2","radius","arc","E","drawErase","Polygon","pointsArray","useRawVertices","sides","_intersectionCache","intersect","line","cacheKey","point1","point2","points","start","end","intersection","erase","show","draw","hatch","Plot","_type","segments","angles","pres","dir","calcIndex","pol","addSegment","_a","_pres","_degrees","pop","reduce","sum","len","endPlot","pressure","_d","curving","index","map0","map1","abs","suma","genPol","_x","_y","_side","step","numSteps","pos","pside","prevIdx","scale","origin","stroke","_pathArray","_current","_curvature","_strokeArray","_strokeOrigin","SubPath","isClosed","curvature","vert","vertex","_createSpline","endPath","sub","pep","tep","pep2","done","p1","p2","p3","d1","d2","a1","a2","curvAdjust","dmax","temp","temp2","point3","intPt","halfDist","arcLength","asin","_drawingLoop","_time","_isLoop","_fps","frameCount","frameRate","fps","drawLoop","timeStamp","endFrame","requestAnimationFrame","matrix","isReady","program","frag","vsSource","fsSource","enable","BLEND","blendFunc","ONE_MINUS_DST_ALPHA","ONE","Attr","getAttribLocation","Frag","glDraw","stride","BYTES_PER_ELEMENT","circleData","circles","offset","alpha","vao","buf","attribs","createVertexArray","bindVertexArray","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","loc","enableVertexAttribArray","vertexAttribPointer","size","FLOAT","createAndBindBuffer","uniformMatrix4fv","u_matrix","u_drawSquare","isSquare","POINTS","deleteBuffer","deleteVertexArray","square","weight","clipWindow","_position","_flow","BrushState","BrushSetState","state","add","params","includes","param","colors","buffers","pick","brushName","has","strokeStyle","arguments","initializeDrawingState","flow","plot","gaussians","angleScale","isPlot","cp","min_max","calculateAlpha","markerTip","saveState","stepSize","spacing","totalSteps","tip","customPressure","isInsideClippingArea","calculatePressure","vibration","sw","iterations","ceil","quality","rX","yRandomFactor","sqrtPart","drawSpray","drawMarker","vibrate","rx","ry","translate","adjustSizeAndRotation","drawCustomOrImage","definition","gauss","drawDefault","simPressure","curve","pow","opacity","o","diameter","_vals","_standard_brushes","obj","HatchState","options","rand","continuous","gradient","createHatch","polygons","hBrush","values","isArray","overallBB","overall","minX","Infinity","minY","maxX","maxY","poly","bb","computeBoundingBoxForPolygon","computeOverallBoundingBox","ventana","startY","dots","dist1","linea","tempArray","flat","sort","gdots","filter","dd","continuousLine","polygon","_boundingBox","FillState","fillBleed","_i","_direction","bleed_strength","direction","fillTexture","_texture","_border","texture_strength","border_strength","fillPolygon","prototype","_brush","_weight","_dist","_angle","_options","HatchSetState","gaussiansA","gaussiansB","FillPolygon","_v","_m","_center","isFirst","sizeX","sizeY","midP","v1","v2","side","rt","isLeft","int","trim","factor","numTrim","splice","grow","growthFactor","tr_v","tr_m","tr_dir","outLen","newVerts","newMods","newDirs","bleedDirDeg","mod","cv","nv","rotDeg","sideX","sideY","dirX","dirY","intensity","lineCap","darker","pols","layer","numLayers","numCircles","halfSizeX","halfSizeY","minSize","minSizeFactor","maxSizeFactor","midX","midY","globalCompositeOperation","_opacity","_bleed","vLength","fluid","strength","modifiers","_","multiplier","shift","center","pts","first","last","twicearea","nPts","calcCenter","createFill","FillSetState","startAngle","endAngle","arcAngle","startX","keys","angleOffset","randomFactor","randomAngle","offsetX","offsetY","region","img","call","brush","from","canvasID","drawingLoop","mode","getTransform","scaleFactor","_array_points"],"mappings":"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","x_google_ignoreList":[0,1]}